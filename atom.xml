<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-04T03:28:21.972Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>f-dAd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS执行机制(一)：变量提升函数调用栈</title>
    <link href="http://example.com/2021/11/03/%E6%B5%8F%E8%A7%88%E5%99%A8js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/11/03/%E6%B5%8F%E8%A7%88%E5%99%A8js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-11-03T08:59:32.000Z</published>
    <updated>2021-11-04T03:28:21.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升">变量提升</h2><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">var myname = '极客时间'</code></pre><p>这段代码你可以把它看成是两行代码组成的：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">var myname    //声明部分myname = '极客时间'  //赋值部分</code></pre><p><img src="https://static001.geekbang.org/resource/image/ec/3c/ec882f2d9deec26ce168b409f274533c.png" alt="img"></p><p>上面是变量的声明和赋值，那接下来我们再来看看函数的声明和赋值，上面是变量的声明和赋值，那接下来我们再来看看函数的声明和赋值，结合下面这段代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function foo()&#123;  console.log('foo')&#125;var bar = function()&#123;  console.log('bar')&#125;</code></pre><p>第一个函数foo是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量bar，再把<code>function()&#123;console.log('bar')&#125;</code>赋值给bar。为了直观理解，你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/61/77/611c09ab995b9b608d9c0db193266777.png" alt="img"></p><p><strong>所谓的变量提升，是指在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的undefined</strong>。</p><h2 id="JavaScript代码的执行流程">JavaScript代码的执行流程</h2><p>从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但，这并不准确。实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被JavaScript引擎放入内存中。对，你没听错，一段JavaScript代码在执行之前需要被JavaScript引擎编译，编译完成之后，才会进入执行阶段。大致流程你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/64/1e/649c6e3b5509ffd40e13ce9c91b3d91e.png" alt="img"></p><h3 id="1-编译阶段">1. 编译阶段</h3><p>那么编译阶段和变量提升存在什么关系呢？</p><p>为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便介绍，可以把这段代码分成两部分。</p><p><strong>第一部分：变量提升部分的代码。</strong></p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var myname = undefinedfunction showName() &#123;    console.log('函数showName被执行');&#125;</code></pre><p><strong>第二部分：执行部分的代码。</strong></p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">showName()console.log(myname)myname = '极客时间'</code></pre><p>下面我们就可以把JavaScript的执行流程细化，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png" alt="img"></p><p>从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。</p><p>执行上下文是JavaScript执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。</p><p>现在你只需要知道，在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量myname和函数showName，都保存在该对象中。</p><p>你可以简单地把变量环境对象看成是如下结构</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">VariableEnvironment:     myname -&gt; undefined,      showName -&gt;function : &#123;console.log(myname)</code></pre><p>了解完变量环境对象的结构后，接下来，我们再结合下面这段代码来分析下是如何生成变量环境对象的。</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">showName()console.log(myname)var myname = '极客时间'function showName() &#123;    console.log('函数showName被执行');&#125;</code></pre><p>我们可以一行一行来分析上述代码：</p><ul><li>第1行和第2行，由于这两行代码不是声明操作，所以JavaScript引擎不会做任何处理；</li><li>第3行，由于这行是经过var声明的，因此JavaScript引擎将在环境对象中创建一个名为myname的属性，并使用undefined对其初始化；</li><li>第4行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建一个showName的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript的执行堆和执行栈我会在后续文章中介绍）。 这样就生成了变量环境对象。接下来JavaScript引擎会把声明以外的代码编译为字节码，至于字节码的细节，我也会在后面文章中做详细介绍，你可以类比如下的模拟代码</li></ul><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">showName()console.log(myname)myname = '极客时间'</code></pre><p>好了，现在有了执行上下文和可执行代码了，那么接下来就到了执行阶段了。</p><h3 id="2-执行阶段">2. 执行阶段</h3><p>JavaScript引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程</p><ul><li>当执行到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出“函数showName被执行”结果。</li><li>接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。</li><li>接下来执行第3行，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”，变量环境如下所示：</li></ul><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">VariableEnvironment:     myname -&gt; &quot;极客时间&quot;,      showName -&gt;function : &#123;console.log(myname)</code></pre><p>好了，以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等，这些内容我会在《14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？》那节详细介绍，在本篇文章中你只需要知道JavaScript代码经过编译生成了什么内容就可以了</p><h3 id="代码中出现相同的变量或者函数怎么办？">代码中出现相同的变量或者函数怎么办？</h3><p>现在你已经知道了，在执行一段JavaScript代码之前，会编译代码，并将代码中的函数和变量保存到执行上下文的变量环境中，那么如果代码中出现了重名的函数或者变量，JavaScript引擎会如何处理？</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function showName() &#123;    console.log('极客邦');&#125;showName();function showName() &#123;    console.log('极客时间');&#125;showName();</code></pre><p>在上面代码中，我们先定义了一个showName的函数，该函数打印出来“极客邦”；然后调用showName，并定义了一个showName函数，这个showName函数打印出来的是“极客时间”；最后接着继续调用showName。那么你能分析出来这两次调用打印出来的值是什么吗？</p><p><strong>我们来分析下其完整执行流程</strong>：</p><ul><li><strong>首先是编译阶段</strong>。遇到了第一个showName函数，会将该函数体存放到变量环境中。接下来是第二个showName函数，继续存放至变量环境中，但是变量环境中已经存在一个showName函数了，此时，第二个showName函数会将第一个showName函数覆盖掉。这样变量环境中就只存在第二个showName函数了。</li><li><strong>接下来是执行阶段</strong>。先执行第一个showName函数，但由于是从变量环境中查找showName函数，而变量环境中只保存了第二个showName函数，所以最终调用的是第二个函数，打印的内容是“极客时间”。第二次执行showName函数也是走同样的流程，所以输出的结果也是“极客时间”</li></ul><p>综上所述，<strong>一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数</strong>。</p><h3 id="总结">总结</h3><p>好了，今天就到这里，下面我来简单总结下今天的主要内容：</p><ul><li>JavaScript代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为JavaScript代码在执行之前需要先编译。 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。</li><li>如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。</li><li>以上就是今天所讲的主要内容，当然，学习这些内容并不是让你掌握一些JavaScript小技巧，其主要目的是让你清楚JavaScript的执行机制：先编译，再执行。</li></ul><hr><h2 id="函数调用栈">函数调用栈</h2><p>那么接下来我们就来明确下，哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况</p><ul><li>当JavaScript执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li><li>当使用eval函数的时候，eval的代码也会被编译，并创建执行上下文。</li></ul><p>比如你在写JavaScript代码的时候，有时候可能会遇到栈溢出的错误，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/0c/70/0c9e2c4f7ee8ca59cfa99a6f51510470.png" alt="img"></p><p>那为什么会出现这种错误呢？这就涉及到了调用栈的内容。你应该知道JavaScript中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。因此要讲清楚调用栈，你还要先弄明白函数调用和栈结构</p><h3 id="什么是函数调用">什么是函数调用</h3><p>函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面我们看个简单的示例代码</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var a = 2function add()&#123;var b = 10return  a+b&#125;add()</code></pre><p>这段代码很简单，先是创建了一个add函数，接着在代码的最下面又调用了该函数。</p><p>那么下面我们就利用这段简单的代码来解释下函数调用的过程。</p><p>在执行到函数add()之前，JavaScript引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png" alt="img"></p><p>从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。</p><p>执行上下文准备好之后，便开始执行全局代码，当执行到add这儿时，JavaScript判断这是一个函数调用，那么将执行以下操作：</p><ul><li>首先，从全局执行上下文中，取出add函数代码。</li><li>其次，对add函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li><li>最后，执行代码，输出结果。</li></ul><p>完整流程你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/53/ca/537efd9e96771dc50737117e615533ca.png" alt="img"></p><p>就这样，当执行到add函数的时候，我们就有了两个执行上下文了——全局执行上下文和add函数的执行上下文。</p><p>也就是说在执行JavaScript时，可能会存在多个执行上下文，那么JavaScript引擎是如何管理这些执行上下文的呢？</p><p>答案是通过一种叫<strong>栈的数据结构来管理的</strong>。那什么是栈呢？它又是如何管理这些执行上下文呢？</p><h3 id="JavaScript的调用栈">JavaScript的调用栈</h3><p>JavaScript引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p><p>为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var a = 2function add(b,c)&#123;  return b+c&#125;function addAll(b,c)&#123;var d = 10result = add(b,c)return  a+result+d&#125;addAll(3,6)</code></pre><p>在上面这段代码中，你可以看到它是在addAll函数中调用了add函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？</p><p>下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。</p><p><strong>第一步，创建全局上下文，并将其压入栈底</strong>。如下图所示</p><p><img src="https://static001.geekbang.org/resource/image/a5/1d/a5d7ec1f8f296412acc045835b85431d.png" alt="img"></p><p>从图中你也可以看出，变量a、函数add和addAll都保存到了全局上下文的变量环境对象中。</p><p>全局执行上下文压入到调用栈后，JavaScript引擎便开始执行全局代码了。首先会执行a=2的赋值操作，执行该语句会将全局上下文变量环境中a的值设置为2。设置后的全局上下文的状态如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/1d/1d/1d50269dbc5b4c69f83662ecdd977b1d.png" alt="img"></p><p>接下来，<strong>第二步是调用addAll函数</strong>。当调用该函数时，JavaScript引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/7d/52/7d6c4c45db4ef9b900678092e6c53652.png" alt="img"></p><p>addAll函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是d=10的赋值操作，执行语句会将addAll函数执行上下文中的d由undefined变成了10。</p><p>然后接着往下执行，<strong>第三步，当执行到add函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈</strong>，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/cc/37/ccfe41d906040031a7df1e4f1bce5837.png" alt="img"></p><p>当add函数返回时，该函数的执行上下文就会从栈顶弹出，并将result的值设置为add函数的返回值，也就是9。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/03/96/03ca801a5372f941bf17d6088fee0f96.png" alt="img"></p><p>紧接着addAll执行最后一个相加操作后并返回，addAll的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d0/7b/d0ac1d6e77735338fa97cc9a3f6c717b.png" alt="img"></p><p>至此，整个JavaScript流程执行结束了。</p><p>好了，现在你应该知道了<strong>调用栈是JavaScript引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p><h3 id="在开发中，如何利用好调用栈">在开发中，如何利用好调用栈</h3><h4 id="1-如何利用浏览器查看调用栈的信息">1. 如何利用浏览器查看调用栈的信息</h4><p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p><p>打开“开发者工具”，点击“Source”标签，选择JavaScript代码的页面，然后在第3行加上断点，并刷新页面。你可以看到执行到add函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：</p><p><img src="https://static001.geekbang.org/resource/image/c0/a2/c0d303a289a535b87a6c445ba7f34fa2.png" alt="img"></p><p>从图中可以看出，右边的“call stack”下面显示出来了函数的调用关系：栈的最底部是anonymous，也就是全局的函数入口；中间是addAll函数；顶部是add函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查Bug时，调用栈都是非常有用的。</p><p>除了通过断点来查看调用栈，你还可以使用<code>console.trace()</code>来输出当前的函数调用关系，比如在示例代码中的add函数里面加上了<code>console.trace()</code>，你就可以看到控制台输出的结果，如下图：</p><p><img src="https://static001.geekbang.org/resource/image/ab/ce/abfba06cd23a7704a6eb148cff443ece.png" alt="img"></p><h4 id="2-栈溢出（Stack-Overflow）">2. 栈溢出（Stack Overflow）</h4><p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，<strong>调用栈是有大小的</strong>，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做栈溢出。</p><p>特别是在你写递归代码的时候，就很容易出现<strong>栈溢出</strong>的情况。比如下面这段代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function division(a,b)&#123;    return division(a,b)&#125;console.log(division(1,2))</code></pre><p>当执行时，就会抛出栈溢出错误，抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。</p><p>那为什么会出现这个问题呢？这是因为当JavaScript引擎开始执行这段代码时，它首先调用函数division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p><p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p><h3 id="总结-2">总结</h3><ul><li>每调用一个函数，JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码。</li><li>如果在一个函数A中调用了另外一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶。</li><li>当前函数执行完毕后，JavaScript引擎会将该函数的执行上下文弹出栈。</li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li><li>栈是一种非常重要的数据结构，不光应用在JavaScript语言中，其他的编程语言，如C/C++、Java、Python等语言，在执行过程中也都使用了栈来管理函数之间的调用关系。所以栈是非常基础且重要的知识点，你必须得掌握。</li></ul><h3 id="思考时间">思考时间</h3><p>最后，我给你留个思考题，你可以看下面这段代码：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">function runStack (n) &#123;  if (n === 0) return 100;  return runStack( n- 2);&#125;runStack(50000)</code></pre><p>这是一段递归代码，可以通过传入参数n，让代码递归执行n次，也就意味着调用栈的深度能达到n，当输入一个较大的数时，比如50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">// 优化function runStack(n) &#123;    while (true) &#123;        if (n === 0) &#123;            return 100;        &#125;        if (n === 1) &#123; // 防止陷入死循环            return 200;        &#125;        n = n - 2;    &#125;&#125;console.log(runStack(50000));</code></pre><hr><h2 id="块级作用域：var缺陷以及为什么要引入let和const">块级作用域：var缺陷以及为什么要引入let和const</h2><p>由于JavaScript存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是JavaScript的一个重要设计缺陷</p><p>虽然ECMAScript6（以下简称ES6）已经通过引入块级作用域并配合let、const关键字，来避开了这种设计缺陷，但是由于JavaScript需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。这也加大了你理解概念的难度，因为既要理解新的机制，又要理解变量提升这套机制，关键这两套机制还是同时运行在“一套”系统中的。</p><p>分析为什么在JavaScript中会存在变量提升，以及变量提升所带来的问题；然后再来介绍如何通过块级作用域并配合let和const关键字来修复这种缺陷</p><h3 id="作用域（scope）">作用域（scope）</h3><p>为什么<code>JavaScript</code>中会存在变量提升这个特性，而其他语言似乎都没有这个特性呢？要讲清楚这个问题，我们就得先从作用域讲起</p><p><strong>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期</strong></p><p>在ES6之前，ES的作用域只有两种：全局作用域和函数作用域。</p><ul><li>全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li><li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li></ul><p>在ES6之前，JavaScript只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</p><p>为了更好地理解块级作用域，你可以参考下面的一些示例代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">//if块if(1)&#123;&#125;//while块while(1)&#123;&#125;//函数块function foo()&#123; //for循环块for(let i = 0; i&lt;100; i++)&#123;&#125;//单独一个块&#123;&#125;</code></pre><p>简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。你可以看下面这段C代码：</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-cpp">char* myname = &quot;极客时间&quot;;void showName() &#123;  printf(&quot;%s \n&quot;,myname);  if(0)&#123;    char* myname = &quot;极客邦&quot;;   &#125;&#125;int main()&#123;   showName();   return 0;&#125;</code></pre><p>上面这段C代码执行后，最终打印出来的是上面全局变量myname的值，之所以这样，是因为C语言是支持块级作用域的，所以if块里面定义的变量是不能被if块外面的语句访问到的。</p><p>和Java、C/C++不同，ES6之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到JavaScript会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是JavaScript中的变量提升。</p><h3 id="变量提升所带来的问题">变量提升所带来的问题</h3><p>由于变量提升作用，使用JavaScript来编写和其他语言相同逻辑的代码，都有可能会导致不一样的执行结果。那为什么会出现这种情况呢？主要有以下两种原因。</p><h4 id="变量容易在不被察觉的情况下被覆盖掉">变量容易在不被察觉的情况下被覆盖掉</h4><p>比如我们重新使用JavaScript来实现上面那段C代码，实现后的JavaScript代码如下：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var myname = &quot;极客时间&quot;function showName()&#123;  console.log(myname);  if(0)&#123;   var myname = &quot;极客邦&quot;  &#125;  console.log(myname);&#125;showName()</code></pre><p>执行上面这段代码，打印出来的是undefined，而并没有像前面C代码那样打印出来“极客时间”的字符串。为什么输出的内容是undefined呢？我们再来分析一下。</p><p>首先当刚执行到showName函数调用时，执行上下文和调用栈的状态是怎样的？具体分析过程你可以回顾《08 | 调用栈：为什么JavaScript代码会出现栈溢出？》这篇文章的分析过程，这里我就直接展示出来了，最终的调用栈状态如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/94/c9/944aaeaeb9ee50feea3c7d218acdd5c9.png" alt="img"></p><p>showName函数的执行上下文创建后，JavaScript引擎便开始执行showName函数内部的代码了。首先执行的是：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">console.log(myname);</code></pre><p>执行这段代码需要使用变量myname，结合上面的调用栈状态图，你可以看到这里有两个myname变量：一个在全局执行上下文中，其值是“极客时间”；另外一个在showName函数的执行上下文中，其值是undefined。那么到底该使用哪个呢？</p><p>相信做过JavaScript开发的同学都能轻松回答出来答案：“当然是先使用函数执行上下文里面的变量啦！”的确是这样，这是因为在函数执行过程中，JavaScript会优先从当前的执行上下文中查找变量，由于变量提升，当前的执行上下文中就包含了变量myname，而值是undefined，所以获取到的myname的值就是undefined。</p><p>这输出的结果和其他大部分支持块级作用域的语言都不一样，比如上面C语言输出的就是全局变量，所以这会很容易造成误解，特别是在你会一些其他语言的基础之上，再来学习JavaScript，你会觉得这种结果很不自然。</p><h4 id="2-本应销毁的变量没有被销毁">2. 本应销毁的变量没有被销毁</h4><p>接下来我们再来看下面这段让人误解更大的代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function foo()&#123;  for (var i = 0; i &lt; 7; i++) &#123;  &#125;  console.log(i); &#125;foo()</code></pre><p>如果你使用C语言或者其他的大部分语言实现类似代码，在for循环结束之后，i就已经被销毁了，但是在JavaScript代码中，i的值并未被销毁，所以最后打印出来的是7。</p><p>这同样也是由变量提升而导致的，在创建执行上下文阶段，变量i就已经被提升了，所以当for循环结束之后，变量i并没有被销毁。</p><p>这依旧和其他支持块级作用域的语言表现是不一致的，所以必然会给一些人造成误解。</p><h3 id="ES6是如何解决变量提升带来的缺陷">ES6是如何解决变量提升带来的缺陷</h3><p>上面我们介绍了变量提升而带来的一系列问题，为了解决这些问题，ES6引入了let和const关键字，从而使JavaScript也能像其他语言一样拥有了块级作用域。</p><p>关于let和const的用法，你可以参考下面代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">let x = 5const y = 6x = 7y = 9 //报错，const声明的变量不可以修改</code></pre><p>从这段代码你可以看出来，两者之间的区别是，使用let关键字声明的变量是可以被改变的，而使用const声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级作用域，为了简单起见，在下面的代码中，我统一使用let关键字来演示。</p><p>那么接下来，我们就通过实际的例子来分析下，ES6是如何通过块级作用域来解决上面的问题的？</p><p>你可以先参考下面这段存在变量提升的代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function varTest() &#123;  var x = 1;  if (true) &#123;    var x = 2;  // 同样的变量!    console.log(x);  // 2  &#125;  console.log(x);  // 2&#125;</code></pre><p>在这段代码中，有两个地方都定义了变量x，第一个地方在函数块的顶部，第二个地方在if块的内部，由于var的作用范围是整个函数，所以在编译阶段，会生成如下的执行上下文：</p><p><img src="https://static001.geekbang.org/resource/image/45/bf/4501368679083f3a8e1a9e4a8e316dbf.png" alt="img"></p><p>从执行上下文的变量环境中可以看出，最终只生成了一个变量x，函数体内所有对x的赋值操作都会直接改变变量环境中的x值。</p><p>所以上述代码最后通过console.log(x)输出的是2，而对于相同逻辑的代码，其他语言最后一步输出的值应该是1，因为在if块里面的声明不应该影响到块外面的变量。</p><p>既然支持块级作用域和不支持块级作用域的代码执行逻辑是不一样的，那么接下来我们就来改造上面的代码，让其支持块级作用域。</p><p>这个改造过程其实很简单，只需要把var关键字替换为let关键字，改造后的代码如下</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function letTest() &#123;  let x = 1;  if (true) &#123;    let x = 2;  // 不同的变量    console.log(x);  // 2  &#125;  console.log(x);  // 1&#125;</code></pre><p>执行这段代码，其输出结果就和我们的预期是一致的。这是因为let关键字是支持块级作用域的，所以在编译阶段，JavaScript引擎并不会把if块中通过let声明的变量存放到变量环境中，这也就意味着在if块通过let声明的关键字，并不会提升到全函数可见。所以在if块之内打印出来的值是2，跳出语块之后，打印出来的值就是1了。这种就非常符合我们的编程习惯了：<strong>作用块内声明的变量不影响块外面的变量</strong>。</p><h3 id="JavaScript是如何支持块级作用域的">JavaScript是如何支持块级作用域的</h3><p>现在你知道了ES可以通过使用let或者const关键字来实现块级作用域，不过你是否有过这样的疑问：“在同一段代码中，ES6是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”</p><p>那么接下来，我们就要<strong>站在执行上下文的角度来揭开答案</strong>。</p><p>你已经知道JavaScript引擎是通过变量环境实现函数级作用域的，那么ES6又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function foo()&#123;    var a = 1    let b = 2    &#123;      let b = 3      var c = 4      let d = 5      console.log(a)      console.log(b)    &#125;    console.log(b)     console.log(c)    console.log(d)&#125;   foo()</code></pre><p>当执行上面这段代码的时候，JavaScript引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了let关键字，let关键字会创建块级作用域，那么let关键字是如何影响执行上下文的呢？</p><p>接下来我们就来一步步分析上面这段代码的执行流程。</p><p><strong>第一步是编译并创建执行上下文</strong>，下面是我画出来的执行上下文示意图，你可以参考下</p><p><img src="https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png" alt="img"></p><p>通过上图，我们可以得出以下结论：</p><ul><li>函数内部通过var声明的变量，在编译阶段全都被存放到变量环境里面了。</li><li>通过let声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li><li>在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中。</li><li>接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中a的值已经被设置成了1，词法环境中b的值已经被设置成了2，</li></ul><p>这时候函数的执行上下文就如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png" alt="img"></p><p>从图中可以看出，当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，当执行到作用域内部时，它们都是独立的存在。</p><p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。</p><p>再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给JavaScript引擎，如果没有查找到，那么继续在变量环境中查找。</p><p>这样一个变量查找过程就完成了，你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" alt="img"></p><p>从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了，这个我们会在下篇文章中做详细介绍。</p><p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d4/28/d4f99640d62feba4202aa072f6369d28.png" alt="img"></p><p>通过上面的分析，想必你已经理解了词法环境的结构和工作机制，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript引擎也就同时支持了变量提升和块级作用域了。</p><h3 id="总结-3">总结</h3><p>由于JavaScript的变量提升存在着变量覆盖、变量污染等设计缺陷，所以ES6引入了块级作用域关键字来解决这些问题。</p><h3 id="思考时间-2">思考时间</h3><p>下面给你留个思考题，看下面这样一段代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">let myname= '极客时间'&#123;  console.log(myname)   let myname= '极客邦'&#125;</code></pre><p>你能通过分析词法环境，得出来最终的打印结果吗？</p><p>分析</p><ol><li>在块级作用域中，从<code>开始到let myname= '极客邦'</code>代码之间会形成一个暂时性死区，如果中间去访问变量<code>myname</code>，会报初始化之前不能访问<code>myname</code>的错误。<code>Uncaught ReferenceError</code></li><li>另外上面的一个foo函数也会报d没有定义，d在块级作用域中声明，在外面是访问不到的</li></ol><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function foo()&#123;var a = 1let b = 2&#123;let b = 3var c = 4let d = 5console.log(a)console.log(b)&#125;console.log(b)console.log(c)console.log(d)&#125;foo()</code></pre><h2 id="作用域链和闭包：代码中出现相同的变量，JavaScript引擎如何选择">作用域链和闭包：代码中出现相同的变量，JavaScript引擎如何选择</h2><p>理解作用域链是理解闭包的基础，而闭包在 JavaScript 中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。所以，如果你想学透一门语言，作用域和作用域链一定是绕不开的</p><p>首先我们来看下面这段代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function bar() &#123;    console.log(myName)&#125;function foo() &#123;    var myName = &quot; 极客邦 &quot;    bar()&#125;var myName = &quot; 极客时间 &quot;foo()</code></pre><p>你觉得这段代码中的 bar 函数和 foo 函数打印出来的内容是什么？这就要分析下这两段代码的执行流程。</p><p>通过前面几篇文章的学习，想必你已经知道了如何通过执行上下文来分析代码的执行流程了。那么当这段代码执行到 bar 函数内部时，其调用栈的状态图如下所示：</p><p>![image-20211104105258357](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105258357.png)</p><p>从图中可以看出，全局执行上下文和 foo 函数的执行上下文中都包含变量 myName，那 bar 函数里面 myName 的值到底该选择哪个呢？</p><p>也许你的第一反应是按照调用栈的顺序来查找变量，查找方式如下：</p><ol><li>先查找栈顶是否存在 myName 变量，但是这里没有，所以接着往下查找 foo 函数中的变量。</li><li>在 foo 函数中查找到了 myName 变量，这时候就使用 foo 函数中的 myName。</li></ol><p>如果按照这种方式来查找变量，那么最终执行 bar 函数打印出来的结果就应该是“极客邦”。但实际情况并非如此，如果你试着执行上述代码，你会发现打印出来的结果是“极客时间”。为什么会是这种情况呢？要解释清楚这个问题，那么你就需要先搞清楚作用域链了</p><h3 id="作用域链">作用域链</h3><p>其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。</p><p>当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量， 比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以看下面这张图：</p><p>![image-20211104105341231](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105341231.png)</p><p>从图中可以看出，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。</p><p>现在你知道变量是通过作用域链来查找的了，不过还有一个疑问没有解开，foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？</p><p>要回答这个问题，你还需要知道什么是词法作用域。这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的</p><h3 id="词法作用域">词法作用域</h3><blockquote><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符</p></blockquote><p>这么讲可能不太好理解，你可以看下面这张图</p><p>![image-20211104105420395](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105420395.png)</p><p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</p><p>了解了词法作用域以及 JavaScript 中的作用域链，我们再回过头来看看上面的那个问题：在开头那段代码中，foo 函数调用了 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文?</p><p>这是因为根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系</p><h2 id="块级作用域中的变量查找">块级作用域中的变量查找</h2><p>前面我们通过全局作用域和函数级作用域来分析了作用域链，那接下来我们再来看看块级作用域中变量是如何查找的？在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。</p><p>我们还是先看下面这段代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function bar() &#123;    var myName = &quot; 极客世界 &quot;    let test1 = 100    if (1) &#123;        let myName = &quot;Chrome 浏览器 &quot;        console.log(test)    &#125;&#125;function foo() &#123;    var myName = &quot; 极客邦 &quot;    let test = 2    &#123;        let test = 3        bar()    &#125;&#125;var myName = &quot; 极客时间 &quot;let myAge = 10let test = 1foo()</code></pre><p>你可以自己先分析下这段代码的执行流程，看看能否分析出来执行结果。</p><p>要想得出其执行结果，那接下来我们就得站在作用域链和词法环境的角度来分析下其执行过程。</p><p>在上篇文章中我们已经介绍过了，ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：</p><p>![image-20211104105559775](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105559775.png)</p><p>现在是执行到 bar 函数的 if 语块之内，需要打印出来变量 test，那么就需要查找到 test 变量的值，其查找过程我已经在上图中使用序号 1、2、3、4、5 标记出来了。</p><p>下面我就来解释下这个过程。首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。</p><p>至于单个执行上下文中如何查找变量，我在上一篇文章中已经做了介绍，这里就不重复了。</p><h2 id="闭包">闭包</h2><p>了解了作用域链，接着我们就可以来聊聊闭包了。关于闭包，理解起来可能会是一道坎，特别是在你不太熟悉 JavaScript 这门语言的时候，接触闭包很可能会让你产生一些挫败感，因为你很难通过理解背后的原理来彻底理解闭包，从而导致学习过程中似乎总是似懂非懂。最要命的是，JavaScript 代码中还总是充斥着大量的闭包代码。</p><p>但理解了变量环境、词法环境和作用域链等概念，那接下来你再理解什么是 JavaScript 中的闭包就容易多了。这里你可以结合下面这段代码来理解什么是闭包：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function foo() &#123;    var myName = &quot; 极客时间 &quot;    let test1 = 1    const test2 = 2    var innerBar = &#123;        getName:function()&#123;            console.log(test1)            return myName        &#125;,        setName:function(newName)&#123;            myName = newName        &#125;    &#125;    return innerBar&#125;var bar = foo()bar.setName(&quot; 极客邦 &quot;)bar.getName()console.log(bar.getName())</code></pre><p>首先我们看看当执行到 foo 函数内部的return innerBar这行代码时调用栈的情况，你可以参考下图：</p><p>![image-20211104105628856](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105628856.png)</p><p>从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。</p><p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p><p>![image-20211104105644991](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105644991.png)</p><p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p><p>之所以是专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。</p><p>好了，现在我们终于可以给闭包一个正式的定义了。在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</p><p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的myName = &quot;极客邦&quot;这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：![image-20211104105700123](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105700123.png)</p><p>从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以调用 setName 时，会修改 foo 闭包中的 myName 变量的值。</p><p>同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。</p><p>你也可以通过“开发者工具”来看看闭包的情况，打开 Chrome 的“开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：</p><p>![image-20211104105720467](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104105720467.png)</p><p>从图中可以看出来，当调用 bar.getName 的时候，右边 Scope 项就体现出了作用域链的情况：Local 就是当前的 getName 函数的作用域，Closure(foo) 是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从“Local–&gt;Closure(foo)–&gt;Global”就是一个完整的作用域链。</p><p>所以说，你以后也可以通过 Scope 来查看实际代码作用域链的情况，这样调试代码也会比较方便。</p><h2 id="闭包是怎么回收的"><a href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson10.html#%E9%97%AD%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E6%94%B6%E7%9A%84">#</a>闭包是怎么回收的</h2><p>理解什么是闭包之后，接下来我们再来简单聊聊闭包是什么时候销毁的。因为如果闭包使用不正确，会很容易造成内存泄漏的，关注闭包是如何回收的能让你正确地使用闭包。</p><p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p><p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p><p>所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p><p>关于闭包回收的问题本文只是做了个简单的介绍，其实闭包是如何回收的还牵涉到了 JavaScript 的垃圾回收机制，而关于垃圾回收，后续章节我会再为你做详细介绍的</p><h3 id="总结-4">总结</h3><p>好了，今天的内容就讲到这里，下面我们来回顾下今天的内容：</p><p>首先，介绍了什么是作用域链，我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。 其次，介绍了在块级作用域中是如何通过作用域链来查找变量的。 最后，又基于作用域链和词法环境介绍了到底什么是闭包。 通过展开词法作用域，我们介绍了 JavaScript 中的作用域链和闭包；通过词法作用域，我们分析了在 JavaScript 的执行过程中，作用域链是已经注定好了，比如即使在 foo 函数中调用了 bar 函数，你也无法在 bar 函数中直接使用 foo 函数中的变量信息。</p><p>因此理解词法作用域对于你理解 JavaScript 语言本身有着非常大帮助，比如有助于你理解下一篇文章中要介绍的 this。另外，理解词法作用域对于你理解其他语言也有很大的帮助，因为它们的逻辑都是一样的</p><h3 id="思考时间-3">思考时间</h3><p>今天留给你的思考题是关于词法作用域和闭包，我修改了上面那段产生闭包的代码，如下所示：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var bar = &#123;    myName:&quot;time.geekbang.com&quot;,    printName: function () &#123;        console.log(myName)    &#125;    &#125;function foo() &#123;    let myName = &quot; 极客时间 &quot;    return bar.printName&#125;let myName = &quot; 极客邦 &quot;let _printName = foo()_printName()bar.printName()</code></pre><p>在上面这段代码中有三个地方定义了 myName，分析这段代码，你觉得这段代码在执行过程中会产生闭包吗？最终打印的结果是什么？</p><blockquote><p>这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，结果都是“极客邦”，也不会形成闭包</p></blockquote><h2 id="this：从JavaScript执行上下文视角讲this">this：从JavaScript执行上下文视角讲this</h2><p>在上篇文章中，我们讲了词法作用域、作用域链以及闭包，并在最后思考题中留了下面这样一段代码</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var bar = &#123;    myName:&quot;time.geekbang.com&quot;,    printName: function () &#123;        console.log(myName)    &#125;    &#125;function foo() &#123;    let myName = &quot; 极客时间 &quot;    return bar.printName&#125;let myName = &quot; 极客邦 &quot;let _printName = foo()_printName()bar.printName()</code></pre><p>相信你已经知道了，在 printName 函数里面使用的变量 myName 是属于全局作用域下面的，所以最终打印出来的值都是“极客邦”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构来确定的。</p><p>不过按照常理来说，调用bar.printName方法时，该方法内部的变量 myName 应该使用 bar 对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的，比如我用 C++ 改写了上面那段代码，如下所示：</p><p class="code-caption" data-lang="c" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-c">#include &lt;iostream&gt;using namespace std;class Bar&#123;    public:    char* myName;    Bar()&#123;      myName = &quot;time.geekbang.com&quot;;    &#125;    void printName()&#123;       cout&lt;&lt; myName &lt;&lt;endl;    &#125;  &#125; bar; char* myName = &quot; 极客邦 &quot;;int main() &#123;bar.printName();return 0;&#125;</code></pre><p>在这段 C++ 代码中，我同样调用了 bar 对象中的 printName 方法，最后打印出来的值就是 bar 对象的内部变量 myName 值——“<a href="http://time.geekbang.com">time.geekbang.com</a>”，而并不是最外面定义变量 myName 的值——“极客邦”，所以在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套this 机制。</p><p>所以，在 JavaScript 中可以使用 this 实现在 printName 函数中访问到 bar 对象的 myName 属性了。具体该怎么操作呢？你可以调整 printName 的代码，如下所示：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">printName: function () &#123;  console.log(this.myName)&#125;</code></pre><p>接下来咱们就展开来介绍 this，不过在讲解之前，希望你能区分清楚作用域链和this是两套不同的系统，它们之间基本没太多联系。在前期明确这点，可以避免你在学习 this 的过程中，和作用域产生一些不必要的关联。</p><h3 id="JavaScript-中的-this-是什么">JavaScript 中的 this 是什么</h3><p>关于 this，我们还是得先从执行上下文说起。在前面几篇文章中，我们提到执行上下文中包含了变量环境、词法环境、外部环境，但其实还有一个 this 没有提及，具体你可以参考下图：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/1.png" alt="img"></p><p>从图中可以看出，this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。前面《08 | 调用栈：为什么 JavaScript 代码会出现栈溢出？》中我们提到过，执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p><p>那么接下来我们就重点讲解下全局执行上下文中的 this和函数执行上下文中的 this。</p><h3 id="全局执行上下文中的-this">全局执行上下文中的 this</h3><p>首先我们来看看全局执行上下文中的 this 是什么。</p><p>你可以在控制台中输入console.log(this)来打印出来全局执行上下文中的 this，最终输出的是 window 对象。所以你可以得出这样一个结论：全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象</p><h3 id="函数执行上下文中的-this">函数执行上下文中的 this</h3><p>现在你已经知道全局对象中的 this 是指向 window 对象了，那么接下来，我们就来重点分析函数执行上下文中的 this。还是先看下面这段代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function foo()&#123;  console.log(this)&#125;foo()</code></pre><blockquote><p>我们在 foo 函数内部打印出来 this 值，执行这段代码，打印出来的也是 window 对象，这说明在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。估计你会好奇，那能不能设置执行上下文中的 this 来指向其他对象呢？答案是肯定的。通常情况下，有下面三种方式来设置函数执行上下文中的 this 值</p></blockquote><p><strong>1. 通过函数的 call 方法设置</strong></p><p>你可以通过函数的call方法来设置函数执行上下文的 this 指向，比如下面这段代码，我们就并没有直接调用 foo 函数，而是调用了 foo 的 call 方法，并将 bar 对象作为 call 方法的参数</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">let bar = &#123;  myName : &quot; 极客邦 &quot;,  test1 : 1&#125;function foo()&#123;  this.myName = &quot; 极客时间 &quot;&#125;foo.call(bar)console.log(bar)console.log(myName)</code></pre><p>执行这段代码，然后观察输出结果，你就能发现 foo 函数内部的 this 已经指向了 bar 对象，因为通过打印 bar 对象，可以看出 bar 的 myName 属性已经由“极客邦”变为“极客时间”了，同时在全局执行上下文中打印 myName，JavaScript 引擎提示该变量未定义。</p><p>其实除了 call 方法，你还可以使用bind和apply方法来设置函数执行上下文中的 this，它们在使用上还是有一些区别的，如果感兴趣你可以自行搜索和学习它们的使用方法，这里我就不再赘述了。</p><p><strong>2. 通过对象调用方法设置</strong></p><p>要改变函数执行上下文中的 this 指向，除了通过函数的 call 方法来实现外，还可以通过对象调用的方式，比如下面这段代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var myObj = &#123;  name : &quot; 极客时间 &quot;,   showThis: function()&#123;    console.log(this)  &#125;&#125;myObj.showThis()</code></pre><p>在这段代码中，我们定义了一个 myObj 对象，该对象是由一个 name 属性和一个 showThis 方法组成的，然后再通过 myObj 对象来调用 showThis 方法。执行这段代码，你可以看到，最终输出的 this 值是指向 myObj 的。</p><p>所以，你可以得出这样的结论：使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。</p><p>其实，你也可以认为 JavaScript 引擎在执行myObject.showThis()时，将其转化为了：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">myObj.showThis.call(myObj)</code></pre><p>接下来我们稍微改变下调用方式，把 showThis 赋给一个全局对象，然后再调用该对象，代码如下所示：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var myObj = &#123;  name : &quot; 极客时间 &quot;,  showThis: function()&#123;    this.name = &quot; 极客邦 &quot;    console.log(this)  &#125;&#125;var foo = myO</code></pre><p>执行这段代码，你会发现 this 又指向了全局 window 对象。</p><p>所以通过以上两个例子的对比，你可以得出下面这样两个结论：</p><p>在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。</p><p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。</p><p><strong>3. 通过构造函数中设置</strong></p><p>你可以像这样设置构造函数中的 this，如下面的示例代码</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function CreateObj()&#123;  this.name = &quot; 极客时间 &quot;&#125;var myObj = new CreateObj()</code></pre><p>在这段代码中，我们使用 new 创建了对象 myObj，那你知道此时的构造函数 CreateObj 中的 this 到底指向了谁吗？</p><p>其实，当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：</p><ul><li>首先创建了一个空对象 tempObj；</li><li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li><li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li><li>最后返回 tempObj 对象。</li></ul><p>为了直观理解，我们可以用代码来演示下</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var tempObj = &#123;&#125;CreateObj.call(tempObj)return tempObj</code></pre><p>这样，我们就通过 new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。</p><h2 id="this-的设计缺陷以及应对方案">this 的设计缺陷以及应对方案</h2><p>就我个人而言，this 并不是一个很好的设计，因为它的很多使用方法都冲击人的直觉，在使用过程中存在着非常多的坑。下面咱们就来一起看看那些 this 设计缺陷。</p><p><strong>1. 嵌套函数中的 this 不会从外层函数中继承</strong></p><p>我认为这是一个严重的设计错误，并影响了后来的很多开发者，让他们“前赴后继”迷失在该错误中。我们还是结合下面这样一段代码来分析下：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var myObj = &#123;  name : &quot; 极客时间 &quot;,   showThis: function()&#123;    console.log(this)    function bar()&#123;console.log(this)&#125;    bar()  &#125;&#125;myObj.showThis()</code></pre><p>我们在这段代码的 showThis 方法里面添加了一个 bar 方法，然后接着在 showThis 函数中调用了 bar 函数，那么现在的问题是：bar 函数中的 this 是什么？</p><p>如果你是刚接触 JavaScript，那么你可能会很自然地觉得，bar 中的 this 应该和其外层 showThis 函数中的 this 是一致的，都是指向 myObj 对象的，这很符合人的直觉。但实际情况却并非如此，执行这段代码后，你会发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。这就是 JavaScript 中非常容易让人迷惑的地方之一，也是很多问题的源头。</p><p>你可以通过一个小技巧来解决这个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下所示：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var myObj = &#123;  name : &quot; 极客时间 &quot;,   showThis: function()&#123;    console.log(this)    var self = this    function bar()&#123;      self.name = &quot; 极客邦 &quot;    &#125;    bar()  &#125;&#125;myObj.showThis()console.log(myObj.name)console.log(window.name)</code></pre><p>执行这段代码，你可以看到它输出了我们想要的结果，最终 myObj 中的 name 属性值变成了“极客邦”。其实，这个方法的的本质是把 this 体系转换为了作用域的体系。</p><p>其实，你也可以使用 ES6 中的箭头函数来解决这个问题，结合下面代码：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">var myObj = &#123;  name : &quot; 极客时间 &quot;,   showThis: function()&#123;    console.log(this)    var bar = ()=&gt;&#123;      this.name = &quot; 极客邦 &quot;      console.log(this)    &#125;    bar()  &#125;&#125;myObj.showThis()console.log(myObj.name)console.log(window.name)</code></pre><p>执行这段代码，你会发现它也输出了我们想要的结果，也就是箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p><p>通过上面的讲解，你现在应该知道了 this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。要解决这个问题，你可以有两种思路：</p><ul><li>第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。</li><li>第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this</li></ul><p><strong>2. 普通函数中的 this 默认指向全局对象 window</strong></p><p>上面我们已经介绍过了，在默认情况下调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。</p><p>不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。</p><p>这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了</p><h3 id="总结-5">总结</h3><p>好了，今天就到这里，下面我们来回顾下今天的内容。</p><p>首先，在使用 this 时，为了避坑，你要谨记以下三点：</p><p>当函数作为对象的方法调用时，函数中的 this 就是该对象； 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window； 嵌套函数中的 this 不会继承外层函数的 this 值。 最后，我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;变量提升&quot;&gt;变量提升&lt;/h2&gt;
&lt;p class=&quot;code-caption&quot; data-lang=&quot;text&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=</summary>
      
    
    
    
    <category term="浏览器原理" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Js" scheme="http://example.com/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>渲染流程：HTML、CSS和JavaScript是如何变成页面的</title>
    <link href="http://example.com/2021/11/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/11/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</id>
    <published>2021-11-03T08:49:32.000Z</published>
    <updated>2021-11-03T09:33:10.291Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用JavaScript优化动画流程，通过优化样式表来防止强制同步布局，等等。</p><p>既然它的功能这么强大，那么今天，我们就来好好聊聊渲染流程。</p><p>通常，我们编写好HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p><p><img src="https://static001.geekbang.org/resource/image/2b/79/2b08a85c63bee68c6fd95dabb648fd79.png" alt="img"></p><p>从图中可以看出，左边输入的是HTML、CSS、JavaScript数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。这中间的渲染模块就是我们今天要讨论的主题。</p><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png" alt="img"></p><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容</p><ul><li>开始每个子阶段都有其输入的内容；</li><li>然后每个子阶段有其处理过程；</li><li>最终每个子阶段会生成输出内容。</li></ul><p>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</p><h2 id="构建DOM树"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson05.html#%E6%9E%84%E5%BB%BAdom%E6%A0%91">#</a>构建DOM树</h2><p><strong>为什么要构建DOM树呢</strong>？这是因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树。</p><p>这里我们还需要简单介绍下什么是树结构，为了更直观地理解，你可以参考下面我画的几个树结构：</p><p><img src="https://static001.geekbang.org/resource/image/fc/38/fcad0a4e3e73c796f00d6120284a3638.png" alt="img"></p><p>从图中可以看出，树这种结构非常像我们现实生活中的“树”，其中每个点我们称为节点，相连的节点称为父子节点。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p><p>接下来咱们还是言归正传，来看看DOM树的构建过程，你可以参考下图</p><p><img src="https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png" alt="img"></p><p>从图中可以看出，构建DOM树的输入内容是一个非常简单的HTML文件，然后经由HTML解析器解析，最终输出树状结构的DOM。</p><p>为了更加直观地理解DOM树，你可以打开Chrome的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的DOM树结构，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/47/73/47f57c3eee749dd838939bfe5dd64573.png" alt="img"></p><p>图中的document就是DOM结构，你可以看到，DOM和HTML内容几乎是一样的，但是和HTML不同的是，DOM是保存在内存中树状结构，可以通过JavaScript来查询或修改其内容。</p><p>那下面就来看看如何通过JavaScript来修改DOM的内容，在控制台中输入：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">document.getElementsByTagName(&quot;p&quot;)[0].innerText = &quot;black&quot;</code></pre><p>这行代码的作用是把第一个<code>&lt;p&gt;</code>标签的内容修改为black，具体执行结果你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/e7/74/e730aa1d73c1151c588e2f8c7e22c274.png" alt="img"></p><p>从图中可以看出，在执行了一段修改第一个<code>&lt;p&gt;</code>标签的JavaScript代码后，DOM的第一个p节点的内容成功被修改，同时页面中的内容也被修改了</p><p>好了，现在我们已经生成DOM树了，但是DOM节点的样式我们依然不知道，要让DOM节点拥有正确的样式，这就需要样式计算了</p><h2 id="样式计算"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson05.html#%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97">#</a>样式计算</h2><p>样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这个阶段大体可分为三步来完成</p><h3 id="1-把CSS转换为浏览器能够理解的结构"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson05.html#_1-%E6%8A%8Acss%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%BD%E5%A4%9F%E7%90%86%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84">#</a>1. 把CSS转换为浏览器能够理解的结构</h3><p>那CSS样式的来源主要有哪些呢？你可以先参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png" alt="img"></p><p>从图中可以看出，CSS样式来源主要有三种：</p><ul><li>通过link引用的外部CSS文件</li><li><style>标记内的 CSS</li><li>元素的style属性内嵌的CSS</li><li>和HTML文件一样，浏览器也是无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheets。</li><li>为了加深理解，你可以在Chrome控制台中查看其结构，只需要在控制台中输入<code>document.styleSheets</code>，然后就看到如下图所示的结构</li></ul><p><img src="https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png" alt="img"></p><p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的CSS文本全部转换为styleSheets结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础</p><h3 id="2-转换样式表中的属性值，使其标准化">2. 转换样式表中的属性值，使其标准化</h3><p>现在我们已经把现有的CSS文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</p><p>要理解什么是属性值标准化，你可以看下面这样一段CSS文本</p><p class="code-caption" data-lang="css" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-css">body &#123; font-size: 2em &#125;p &#123;color:blue;&#125;span  &#123;display: none&#125;div &#123;font-weight: bold&#125;div  p &#123;color:green;&#125;div &#123;color:red; &#125;</code></pre><p>可以看到上面的CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p><p>那标准化后的属性值是什么样子的？</p><p><img src="https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png" alt="img"></p><p>从图中可以看到，2em被解析成了32px，red被解析成了rgb(255,0,0)，bold被解析成了700……</p><h3 id="3-计算出DOM树中每个节点的具体样式"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson05.html#_3-%E8%AE%A1%E7%AE%97%E5%87%BAdom%E6%A0%91%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B7%E4%BD%93%E6%A0%B7%E5%BC%8F">#</a>3. 计算出DOM树中每个节点的具体样式</h3><p>现在样式的属性已被标准化了，接下来就需要计算DOM树中每个节点的样式属性了，如何计算呢？</p><p><strong>这就涉及到CSS的继承规则和层叠规则了。</strong></p><p>首先是CSS继承。CSS继承就是每个DOM节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到DOM节点上的</p><p class="code-caption" data-lang="css" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-css">body &#123; font-size: 20px &#125;p &#123;color:blue;&#125;span  &#123;display: none&#125;div &#123;font-weight: bold;color:red&#125;div  p &#123;color:green;&#125;</code></pre><p>这张样式表最终应用到DOM节点的效果如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/fe/b4/fe9a0ea868dc02a3c4a59f6080aa80b4.png" alt="img"></p><p>从图中可以看出，所有子节点都继承了父节点样式。比如body节点的font-size属性是20，那body节点下面的所有节点的font-size都等于20。</p><p>为了加深你对CSS继承的理解，你可以打开Chrome的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面</p><p><img src="https://static001.geekbang.org/resource/image/88/b2/88a3aac427cc7c09361eac01a85fc7b2.png" alt="img"></p><p>这个界面展示的信息很丰富，大致可描述为如下</p><ul><li>首先，可以选择要查看的元素的样式（位于图中的区域2中），在图中的第1个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是<code>&lt;p&gt;</code>标签，位于<code>html.body.div.</code>这个路径下面</li><li>其次，可以从样式来源（位于图中的区域3中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于UserAgent样式表。这里需要特别提下UserAgent样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是UserAgent样式。</li><li>最后，可以通过区域2和区域3来查看样式继承的具体过程。</li></ul><p>以上就是CSS继承的一些特性，样式计算过程中，会根据DOM节点的继承关系来合理计算节点样式。</p><p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法</strong>。它在CSS处于核心地位，CSS的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习</p><p>总之，样式计算阶段的目的是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。这个阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。</p><p>如果你想了解每个DOM元素最终的计算样式，可以打开Chrome的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d8/46/d87415b0187e3860404bf963f1c3d646.png" alt="img"></p><p>上图红色方框中显示了html.body.div.p标签的ComputedStyle的值。你想要查看哪个元素，点击左边对应的标签就可以了</p><h2 id="布局阶段">布局阶段</h2><p>现在，我们有DOM树和DOM树中元素的样式，但这还不足以显示页面，因为我们还不知道DOM元素的几何位置信息。那么接下来就需要计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。</p><p>Chrome在布局阶段需要完成两个任务：创建布局树和布局计算</p><h3 id="1-创建布局树">1. 创建布局树</h3><p>你可能注意到了DOM树还含有很多不可见的元素，比如head标签，还有使用了<code>display:none</code>属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p><p>我们结合下图来看看布局树的构造过程：</p><p><img src="https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png" alt="img"></p><p>从上图可以看出，DOM树中所有不可见的节点都没有包含到布局树中。</p><p>为了构建布局树，浏览器大体上完成了下面这些工作</p><ul><li>遍历DOM树中的所有可见节点，并把这些节点加到布局中；</li><li>而不可见的节点会被布局树忽略掉，如<code>head</code>标签下面的全部内容，再比如<code>body.p.span</code>这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树</li></ul><h3 id="2-布局计算">2. 布局计算</h3><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p><p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome团队正在重构布局代码，下一代布局系统叫LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p><h2 id="上半部分总结">上半部分总结</h2><p><img src="https://static001.geekbang.org/resource/image/a4/9a/a4a0ea4da58260aafc9aabdd37613f9a.png" alt="img"></p><p>从图中可以看出，本节内容我们介绍了渲染流程的前三个阶段：DOM生成、样式计算和布局。要点可大致总结为如下：</p><ul><li>浏览器不能直接理解HTML数据，所以第一步需要将其转换为浏览器能够理解的DOM树结构；</li><li>生成DOM树后，还需要根据CSS样式表，来计算出DOM树所有节点的样式；</li><li>最后计算DOM元素的布局信息，使其都保存在布局树中。</li></ul><h2 id="分层">分层</h2><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p><p>答案依然是否定的。</p><p>因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。如果你熟悉PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p><p>要想直观地理解什么是图层，你可以打开Chrome的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示</p><p><img src="https://static001.geekbang.org/resource/image/e2/c0/e2c917edf5119cddfbec9481372f8fc0.png" alt="img"></p><p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图</p><p><img src="https://static001.geekbang.org/resource/image/cd/78/cd6aac705501d48bda6e8eebca058b78.png" alt="img"></p><p>现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p><p><img src="https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png" alt="img"></p><p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的span标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p><p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p><p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong></p><p>页面是个二维平面，但是层叠上下文能够让HTML元素具有三维概念，这些HTML元素按照自身属性的优先级分布在垂直于这个二维平面的z轴上。你可以结合下图来直观感受下：</p><p><img src="https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png" alt="img"></p><p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性。</p><p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层。</strong></p><p>不过首先你需要了解什么是剪裁，结合下面的HTML代码：</p><p class="code-caption" data-lang="html" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-html">&lt;style&gt;      div &#123;            width: 200;            height: 200;            overflow:auto;            background: gray;        &#125; &lt;/style&gt;&lt;body&gt;    &lt;div &gt;        &lt;p&gt;所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：&lt;/p&gt;        &lt;p&gt;从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。&lt;/p&gt;        &lt;p&gt;图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。&lt;/p&gt;     &lt;/div&gt;&lt;/body&gt;</code></pre><p>在这里我们把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，下图是运行时的执行结果</p><p><img src="https://static001.geekbang.org/resource/image/6a/0c/6a583733735edc1e4d7946740eb6fc0c.png" alt="img"></p><p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png" alt="img"></p><p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。</p><h2 id="图层绘制"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson06.html#%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6">#</a>图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p><p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p><p><strong>通常，你会把你的绘制操作分解为三步</strong>：</p><ul><li>制蓝色背景；</li><li>在中间绘制一个红色的圆；</li><li>再在圆上绘制绿色三角形</li></ul><p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png" alt="img"></p><p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p><p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png" alt="img"></p><p>在该图中，区域1就是document的绘制列表，拖动区域2中的进度条可以重现列表的绘制过程。</p><h2 id="栅格化（raster）操作">栅格化（raster）操作</h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p><p><img src="https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png" alt="img"></p><p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p><p>那我们得先来看看什么是视口，你可以参看下图：</p><p><img src="https://static001.geekbang.org/resource/image/24/72/242225112f2a3ec97e736c960b88d972.png" alt="img"></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</p><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是256x256或者512x512，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png" alt="img"></p><p>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png" alt="img"></p><p>通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。</p><p>相信你还记得，GPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png" alt="img"></p><p>从图中可以看出，渲染进程把生成图块的指令发送给GPU，然后在GPU中执行生成图块的位图，并保存在GPU的内存中。</p><h2 id="合成和显示">合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。</p><h2 id="渲染流水线大总结">渲染流水线大总结</h2><p>好了，我们现在已经分析完了整个渲染流程，从HTML到DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p><p><img src="https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png" alt="img"></p><p><strong>结合上图，一个完整的渲染流程大致可总结为如下</strong></p><ul><li>渲染进程将HTML内容转换为能够读懂的DOM树结构。</li><li>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令DrawQuad给浏览器进程。</li><li>浏览器进程根据DrawQuad消息生成页面，并显示到显示器上</li></ul><h2 id="相关概念"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson06.html#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">#</a>相关概念</h2><p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续Web的性能优化会有很大帮助。</p><h3 id="1-更新了元素的几何属性（重排）">1. 更新了元素的几何属性（重排）</h3><p><img src="https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png" alt="img"></p><p>从上图可以看出，如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的</p><h3 id="2-更新元素的绘制属性（重绘）">2. 更新元素的绘制属性（重绘）</h3><p>接下来，我们再来看看重绘，比如通过JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png" alt="img"></p><p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。<strong>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p><h3 id="3-直接合成阶段">3. 直接合成阶段</h3><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图</p><p><img src="https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png" alt="img"></p><p>在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p><p>至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行</p><h2 id="总结">总结</h2><p>通过本文的分析，你应该可以看到，Chrome的渲染流水线还是相当复杂晦涩，且难以理解，不过Chrome团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效，正所谓大道至简。</p><h2 id="思考时间">思考时间</h2><p>在优化Web性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化Web性能吗？那又有那些具体的实践方法能减少重绘、重排呢？</p><ul><li>触发repaint reflow的操作尽量放在一起，比如改变dom高度和设置margin分开写，可能会出发两次重排</li><li>通过虚拟dom层计算出操作总得差异，一起提交给浏览器。之前还用过createdocumentfragment来汇总append的dom,来减少触发重排重绘次数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇文章中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿</summary>
      
    
    
    
    <category term="浏览器原理-宏观" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86-%E5%AE%8F%E8%A7%82/"/>
    
    
    <category term="渲染" scheme="http://example.com/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>导航流程：从输入URL到页面展示这中间发生了什么</title>
    <link href="http://example.com/2021/11/03/url%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/11/03/url%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/</id>
    <published>2021-11-03T07:19:32.000Z</published>
    <updated>2021-11-03T09:36:52.820Z</updated>
    
    <content type="html"><![CDATA[<p>“在浏览器里，从输入URL到页面展示，这中间发生了什么？ ” “从输入URL到页面展示完整流程示意图”：</p><p><img src="https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png" alt="img"></p><p>从图中可以看出，整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾下浏览器进程、渲染进程和网络进程的主要职责。</p><ul><li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</li><li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</li><li>渲染进程的主要职责是把从网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么Chrome会让渲染进程运行在安全沙箱里，就是为了保证系统的安全</li></ul><p>回顾了浏览器的进程架构后，我们再结合上图来看下这个完整的流程，可以看出，整个流程包含了许多步骤，我把其中几个核心的节点用蓝色背景标记出来了。这个过程可以大致描述为如下：</p><ul><li>首先，用户从浏览器进程里输入请求信息；</li><li>然后，网络进程发起URL请求；</li><li>服务器响应URL请求之后，浏览器进程就又要开始准备渲染进程了；</li><li>渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；</li><li>渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。</li></ul><p>这其中，用户发出URL请求到页面开始解析的这个过程，就叫做导航。下面我们来详细分析下这些步骤，同时也就解答了开头所说的那道经典的面试题。</p><h2 id="从输入URL到页面展示">从输入URL到页面展示</h2><p>知道了浏览器的几个主要进程的职责之后，那么接下来，我们就从浏览器的地址栏开始讲起。</p><h3 id="1-用户输入">1. 用户输入</h3><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的URL。</p><ul><li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。</li><li>如果判断输入内容符合URL规则，比如输入的是 <a href="http://time.geekbang.org">time.geekbang.org</a>，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 <a href="https://time.geekbang.org">https://time.geekbang.org</a>。</li></ul><p>当用户输入关键字并键入回车之后，浏览器便进入下图的状态：</p><p><img src="https://static001.geekbang.org/resource/image/fa/30/fad33fc7c5f2bdf4e20cac7691484130.png" alt="img"></p><p>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p><h3 id="2-URL请求过程">2. URL请求过程</h3><p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。那具体流程是怎样的呢？</p><p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。</p><p>接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</p><p><strong>（1）重定向</strong></p><p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，一切又重头开始了。</p><p>比如，我们在终端里输入以下命令：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">curl -I http://time.geekbang.org/</code></pre><p><code>curl -I + URL</code>的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：</p><p><img src="https://static001.geekbang.org/resource/image/65/7e/655cbf32dd4bb6f9decc5c7f9a535a7e.png" alt="img"></p><p>从图中可以看出，极客时间服务器会通过重定向的方式把所有HTTP请求转换为HTTPS请求。也就是说你使用HTTP向极客时间服务器请求时，服务器会返回一个包含有301或者302状态码响应头，并把响应头的Location字段中填上HTTPS的地址，这就是告诉了浏览器要重新导航到新的地址上。</p><p>下面我们再使用HTTPS协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">curl -I https://time.geekbang.org/</code></pre><p>我们看到服务器返回如下信息：</p><p><img src="https://static001.geekbang.org/resource/image/0c/43/0c4987fe5d05646fa8245d8cc50d1a43.png" alt="img"></p><p>从图中可以看出，服务器返回的响应头的状态码是200，这是告诉浏览器一切正常，可以继续往下处理该请求了。</p><p>好了，以上是重定向内容的介绍。现在你应该理解了，在导航过程中，如果服务器响应行的状态码包含了301、302一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是200，那么表示浏览器可以继续处理该请求。</p><p><strong>（2）响应数据类型处理</strong></p><p>在处理了跳转信息之后，我们继续导航流程的分析。URL请求的数据类型，有时候是一个下载类型，有时候是正常的HTML页面，那么浏览器是如何区分它们呢？</p><p>答案是Content-Type。Content-Type是HTTP头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。</p><p>这里我们还是以极客时间为例，看看极客时间官网返回的Content-Type值是什么。在终端输入以下命令：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">curl -I https://time.geekbang.org/</code></pre><p>返回信息如下图：</p><p><img src="https://static001.geekbang.org/resource/image/89/1c/8951e161b5f44a73e52c16b631a63e1c.png" alt="img"></p><p>从图中可以看到，响应头中的Content-type字段的值是text/html，这就是告诉浏览器，服务器返回的数据是HTML格式。</p><p>接下来我们再来利用curl来请求极客时间安装包的地址，如下所示：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk</code></pre><p>请求后返回的响应头信息如下：</p><p><img src="https://static001.geekbang.org/resource/image/59/3b/595902748d7d4c2f9c1d4783962ae43b.png" alt="img"></p><p>从返回的响应头信息来看，其Content-Type的值是application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</p><p>需要注意的是，如果服务器配置Content-Type不正确，比如将text/html类型配置成application/octet-stream类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。</p><p>所以，不同Content-Type的后续处理流程也截然不同。如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进行导航流程。由于Chrome的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p><h3 id="3-准备渲染进程">3. 准备渲染进程</h3><p>默认情况下，Chrome会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p><p>比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的Chrome的任务管理器截图：</p><p><img src="https://static001.geekbang.org/resource/image/d8/28/d8fe2afbd8ea2d4a8d8cc4bb14c50f28.png" alt="img"></p><p>从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程ID是23601。</p><p>那什么情况下多个页面会同时运行在一个渲染进程中呢？</p><p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，<a href="http://geekbang.org">geekbang.org</a>）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p><p class="code-caption" data-lang="text" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-text">https://time.geekbang.orghttps://www.geekbang.orghttps://www.geekbang.org:8080</code></pre><p>它们都是属于同一站点，因为它们的协议都是HTTPS，<a href="http://xn--geekbang-459lgyz31ckzk800cy7f2n4h1wuc.org">而且根域名也都是geekbang.org</a>。</p><p>Chrome的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。</p><p>那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？比如我通过极客邦页面里的链接打开InfoQ的官网（<a href="https://www.infoq.cn/">https://www.infoq.cn/</a> ）， 因为infoq.cn和geekbang.org不属于同一站点，所以infoq.cn会使用一个新的渲染进程，你可以参考下图</p><p><img src="https://static001.geekbang.org/resource/image/fb/74/fba1dd05f0aeba93a5cb25f305971274.png" alt="img"></p><p>从图中任务管理器可以看出：由于极客邦和极客时间的标签页拥有相同的协议和根域名，所以它们属于同一站点，并运行在同一个渲染进程中；<a href="http://xn--infoq-r63n.xn--cngeekbang-uj2pm2ch22bma387lux7dh19b.org">而infoq.cn的根域名不同于geekbang.org</a>，也就是说InfoQ和极客邦不属于同一站点，因此它们会运行在两个不同的渲染进程之中。</p><p>总结来说，打开一个新页面采用的渲染进程策略就是：</p><ul><li>通常情况下，打开新的页面都会使用单独的渲染进程；</li><li>如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程。</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p><h3 id="4-提交文档">4. 提交文档</h3><p>首先要明确一点，这里的“文档”是指URL请求的响应体数据。</p><ul><li>“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。</li><li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。</li><li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。</li></ul><p>更新内容如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/a1/6f/a1b77a61361561e74e86fdae10ee246f.png" alt="img"></p><p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p><p>到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。</p><h3 id="5-渲染阶段">5. 渲染阶段</h3><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：</p><p><img src="https://static001.geekbang.org/resource/image/be/58/bef45eb5b01c34e328486004feedd658.png" alt="img"></p><p>至此，一个完整的页面就生成了。那文章开头的“从输入URL到页面展示，这中间发生了什么？”这个过程极其“串联”的问题也就解决了。</p><h2 id="域名和端口号是怎么对应起来的？">域名和端口号是怎么对应起来的？</h2><p>客户端输入域名,通过DNS将域名解析成为服务器ip,找到代理服务器,因为http协议服务所占用的端口默认为80端口，所以会访问服务器的80端口,然后再通过代理服务器将请求转发到不同的服务器以及端口中.如图</p><p><img src="https:////upload-images.jianshu.io/upload_images/6928249-fc702a550316922b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/791/format/webp" alt="img"></p><h3 id="应该通过域名访问项目吗？">应该通过域名访问项目吗？</h3><p>答案是必须的。</p><p><strong>如果用IP+端口号的方式访问，会有以下后果</strong></p><p>首先，非常难记,域名是对人友好的有含义的字符，而ip都是4组基本无规律的数字,对人不友好.</p><p>其次， 如果服务器中的资源发生迁移,那么原先的服务器ip地址就无效了,必须要重新使用新的ip地址访问服务器,用户还要再去记忆一遍IP地址。但是如果是使用域名则不存在这个问题.</p><p>最后， 不安全,通过ip直接访问服务器是非常危险的,相当于将整个服务器的大门向所有人打开,造成的后果是别有用心的人能够非常容易攻击到服务器.域名访问就能杜绝这种情况，用户是不知道服务器的IP地址的，而且就算有人通过域名恶意攻击，直接和用户交互的代理服务器也可以保护内容服务器。这样就算代理服务器被攻破，损失也相对较小。</p><h2 id="重定向">重定向</h2><p>在 HTTP 协议中，重定向操作由服务器通过发送特殊的响应（即 redirects）而触发。HTTP 协议的重定向响应的状态码为 3xx 。</p><p>浏览器在接收到重定向响应的时候，会采用该响应提供的新的 URL ，并立即进行加载；大多数情况下，除了会有一小部分性能损失之外，重定向操作对于用户来说是不可见的。</p><p>不同类型的重定向映射可以划分为三个类别：</p><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Redirections$edit#Permanent_redirections">永久重定向</a>  这种重定向操作是永久性的。它表示原 URL 不应再被使用，而应该优先选用新的 URL。搜索引擎机器人会在遇到该状态码时触发更新操作，在其索引库中修改与该资源相关的 URL 。 301 308</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Redirections$edit#Temporary_redirections">临时重定向</a>  有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问。在这种情况下可以使用临时重定向。搜索引擎不会记录该新的、临时的链接。在创建、更新或者删除资源的时候，临时重定向也可以用于显示临时性的进度页面。302 303 307</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Redirections$edit#Special_redirections">特殊重定向</a>  304表示资源未修改，相当于将资源重定向到本地缓存。会使页面跳转到本地陈旧的缓存版本当中（该缓存已过期(?)） 300 手工重定向以 Web 页面形式呈现在浏览器中的消息主体包含了一个可能的重定向链接的列表，用户可以从中进行选择。</p></li></ol><h3 id="301重定向">301重定向</h3><p>当浏览器接收到服务端301（永久）重定向返回码时，会将original_url和redirect_url1存储在浏览器缓存中，当再次请求original_url时，浏览器会从本地缓存中读取redirect_url1直接进行跳转，不再请求服务端。</p><p>在浏览器未清理缓存或缓存未失效的情况下，即使服务端将重定向地址修改为redirect_url2，浏览器依然会跳转到redirect_url1。</p><h3 id="302重定向">302重定向</h3><p>当浏览器接收到服务端302（临时）重定向返回码时，不会进行缓存。每次请求original_url时，都会请求一下服务端。</p><h2 id="总结：从输入URL到页面展示，这中间发生了什么"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson04.html#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">#</a>总结：从输入URL到页面展示，这中间发生了什么</h2><ul><li>用户输入url并回车</li><li>浏览器进程检查url，组装协议，构成完整的url</li><li>浏览器进程通过进程间通信（IPC）把url请求发送给网络进程</li><li>网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li><li>如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下<ul><li>进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？http协议默认80端口，因此域名解析后直接用获取的ip直接访问代理服务器的80端口，代理服务器配置有真正目的服务器的ip和端口）</li><li>利用ip地址和服务器建立tcp连接</li><li>构建请求头信息</li><li>发送请求头信息</li><li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li></ul></li><li>网络进程解析响应流程<ul><li>检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。</li><li>200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</li></ul></li><li>准备渲染进程<ul><li>浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li></ul></li><li>传输数据、更新状态<ul><li>渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”</li><li>渲染进程接收完数据后，向浏览器发送“确认提交”</li><li>浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面</li></ul></li></ul><h2 id="总结">总结</h2><p>好了，今天就到这里，下面我来简单总结下这篇文章的要点：</p><ul><li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li><li>Chrome默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。</li><li>浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li><li>导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“在浏览器里，从输入URL到页面展示，这中间发生了什么？ ” “从输入URL到页面展示完整流程示意图”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d</summary>
      
    
    
    
    <category term="浏览器原理-宏观" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86-%E5%AE%8F%E8%A7%82/"/>
    
    
    <category term="url解析" scheme="http://example.com/tags/url%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Chrome架构：仅仅打开了1个页面，为什么有4个进程</title>
    <link href="http://example.com/2021/11/03/chrome%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2021/11/03/chrome%E6%9E%B6%E6%9E%84/</id>
    <published>2021-11-03T06:29:32.000Z</published>
    <updated>2021-11-03T09:34:58.950Z</updated>
    
    <content type="html"><![CDATA[<p>在开始之前，我们一起看下，Chrome打开一个页面需要启动多少进程？你可以点击Chrome浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开Chrome的任务管理器的窗口，如下图</p><p>![image-20211103113351972](/Users/bytedance/Library/Application Support/typora-user-images/image-20211103113351972.png)</p><p>和Windows任务管理器一样，Chrome任务管理器也是用来展示运行中Chrome使用的进程信息的。从图中可以看到，Chrome启动了4个进程，你也许会好奇，只是打开了1个页面，为什么要启动这么多进程呢？</p><h2 id="单进程浏览器时代">单进程浏览器时代</h2><p>顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示</p><p><img src="https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png" alt="img"></p><p>如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因</p><p><strong>问题1：不稳定</strong></p><p>早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p><p>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p><p><strong>问题2：不流畅</strong></p><p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p><p>比如，下面这个无限循环的脚本：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function freeze() &#123;while (1) &#123;console.log(&quot;freeze&quot;);&#125;&#125;freeze();</code></pre><p>如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？</p><p>因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。</p><p>除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢</p><p><strong>问题3：不安全</strong></p><p>这里依然可以从插件和页面脚本两个方面来解释该原因。</p><p>插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p><p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p><p>以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢</p><h2 id="多进程浏览器时代"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3">#</a>多进程浏览器时代</h2><p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了</p><h3 id="早期多进程架构"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E6%97%A9%E6%9C%9F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84">#</a>早期多进程架构</h3><p>你可以先看看下面这张图，这是2008年Chrome发布时的进程架构。</p><p><img src="https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png" alt="img"></p><p>从图中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信（如图中虚线部分）。</p><p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</p><p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。</p><p>对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p><p><strong>最后我们再来看看上面的两个安全问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p><p>好了，分析完早期的Chrome浏览器后，相信你已经了解了浏览器采用多进程架构的必要性</p><h3 id="目前多进程架构"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84">#</a>目前多进程架构</h3><p>不过Chrome的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的Chrome进程架构，你可以参考下图</p><p><img src="https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png" alt="img"></p><p>从图中可以看出，最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程</p><p>下面我们来逐个分析下这几个进程的功能。</p><ul><li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU进程</strong>。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</li><li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li></ul><p>讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了1个页面，为什么有4个进程？因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。</p><p>不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题</p><ul><li><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li></ul><p>对于上面这两个问题，Chrome团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题</p><h3 id="未来面向服务的架构"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84">#</a>未来面向服务的架构</h3><p>为了解决这些问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称SOA）的思想设计了新的Chrome架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过IPC来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。</p><p>Chrome最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是Chrome“面向服务的架构”的进程模型图</p><p><img src="https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png" alt="img"></p><p>目前Chrome正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。</p><p>Chrome正在逐步构建Chrome基础服务（Chrome Foundation Service），如果你认为Chrome是“便携式操作系统”，那么Chrome基础服务便可以被视为该操作系统的“基础”系统服务层。</p><p>同时Chrome还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome会将很多服务整合到一个进程中，从而节省内存占用。</p><p><img src="https://static001.geekbang.org/resource/image/a9/76/a9ba86d7b03263fa3997d3733d958176.png" alt="img"></p><h2 id="总结"><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>好了，今天就到这里，下面我来简要梳理并总结今天的内容。</p><p>本文我主要是从Chrome进程架构的视角，分析了浏览器的进化史。</p><p>最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后Chrome试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome的架构体系变得越来越复杂，这种架构的复杂性倒逼Chrome开发团队必须进行架构的重构，最终Chrome团队选择了面向服务架构（SOA）形式，这也是Chrome团队现阶段的一个主要任务。</p><p>鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过Chrome开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到Chrome新的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在开始之前，我们一起看下，Chrome打开一个页面需要启动多少进程？你可以点击Chrome浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开Chrome的任务管理器的窗口，如下图&lt;/p&gt;
&lt;p&gt;![image-20211103113351972</summary>
      
    
    
    
    <category term="浏览器原理-宏观" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86-%E5%AE%8F%E8%A7%82/"/>
    
    
    <category term="chrome" scheme="http://example.com/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>electron</title>
    <link href="http://example.com/2021/11/03/electron/"/>
    <id>http://example.com/2021/11/03/electron/</id>
    <published>2021-11-03T03:11:32.000Z</published>
    <updated>2021-12-13T12:55:45.905Z</updated>
    
    <content type="html"><![CDATA[<p>Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 <a href="https://www.chromium.org/">Chromium</a> 和 <a href="https://nodejs.org/">Node.js</a> 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。</p><h3 id="搭建electron应用">搭建electron应用</h3><h2 id="Demo01-搭建一个最简单的-Electron">Demo01: 搭建一个最简单的 Electron</h2><p>首先，我们会搭建一个最简单的 Electron 应用，它只有 3 个文件，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWangYuLue%2Felectron-demos%2Ftree%2Fmaster%2Fdemo01">点这里</a>查看Demo01代码</p><p>创建 <code>demo01</code> 目录：</p><p>1、新建 <code>package.json</code> 文件</p><p class="code-caption" data-lang="json" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-json">&#123;  &quot;name&quot;: &quot;demo01&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;main.js&quot;,  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;../node_modules/.bin/electron .&quot;  &#125;&#125;</code></pre><p>2、新建 <code>index.html</code> 文件</p><p class="code-caption" data-lang="html" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Hello World!&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Hello World!&lt;/h1&gt;    We are using node &lt;script&gt;document.write(process.versions.node)&lt;/script&gt;,    Chrome &lt;script&gt;document.write(process.versions.chrome)&lt;/script&gt;,    and Electron &lt;script&gt;document.write(process.versions.electron)&lt;/script&gt;.  &lt;/body&gt;&lt;/html&gt;</code></pre><p>3、新建 <code>main.js</code> 文件</p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code>const &#123; app, BrowserWindow &#125; = require('electron')function createWindow () &#123;     // 创建浏览器窗口  let win = new BrowserWindow(&#123;    width: 800,    height: 600,    webPreferences: &#123;      nodeIntegration: true    &#125;  &#125;)  // 加载index.html文件  win.loadFile('index.html')&#125;app.whenReady().then(createWindow)复制代码</code></pre><p>运行 <code>yarn start</code>，第一个 electron 项目就轻松启动起来了。</p><p>注意 <code>package.json</code> 中的 <code>main</code> 字段，它指定了 electron 的入口文件。</p><p>在 <code>main.js</code> 中，我们注意到，<code>electron</code> 模块所提供的功能都是通过命名空间暴露出来的。 比如说： <code>electron.app</code> 负责管理 <code>Electron</code> 应用程序的生命周期， <code>electron.BrowserWindow</code> 类负责创建窗口。</p><p>细心的同学注意到，Demo01 其实是 Electorn 官方文档中的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2Fdocs%2Ftutorial%2Ffirst-app">范例</a>；是的，官方的范例写的非常简单友好，所以用它来作为我们一系列 Demo 的开始是非常好的选择。</p><h4 id="主进程">主进程</h4><p>Electron运行package.json的main脚本的进程被称为主进程<br>每个应用只有一-个主进程<br>管理原生GUI,典型的窗口( BrowserWindow、Tray、Dock、Menu)<br>创建渲染进程<br>控制应用生命周期(app)</p><h4 id="渲染进程">渲染进程</h4><p>展示Web页面的进程称为渲染进程， 同web 但web是运行在沙盒中的，这个可以利用node访问系统<br>通过Node.js、Electron 提供的API可以跟系统底层打交道<br>一个Electron应用可以有多个渲染进程.</p><p>![image-20211206111042495](/Users/bytedance/Library/Application Support/typora-user-images/image-20211206111042495.png)</p><h4 id="Electron进程间通信的目的">Electron进程间通信的目的</h4><p>通知事件<br>数据传输<br>共享数据</p><h4 id="IPC模块通信">IPC模块通信</h4><p>Electron 提供了IPC通信模块，主进程的ipcMain和渲染进程的ipcRenderer<br>ipcMain、ipcRenderer 都是EventEmitter对象</p><h4 id="进程间通信-从渲染进程到主进程">进程间通信:从渲染进程到主进程</h4><p>Callback写法:<br>ipcRenderer,send (channel, …args)<br>ipcMain.on(channel, handler)<br>Promise写法(Electron 7.0之后，处理请求+响应模式)<br>ipcRenderer.invoke(channel, …args)<br>ipcMain.handle(channel, handler)</p><h4 id="进程间通信-从主进程到渲染进程">进程间通信:从主进程到渲染进程</h4><p>主进程通知渲染进程:<br>ipcRenderer.on(channel, handler)<br>webContents.send(channel) 一个主进程，多个渲染进程，需要找到具体的渲染进程</p><h4 id="页面间-渲染进程与渲染进程间-通信">页面间( 渲染进程与渲染进程间)通信</h4><p>通知事件<br>通过主进程转发(Electron 5之前)<br>ipcRenderer.sendTo (Electron 5之后)<br>数据共享<br>Web 技术( localStorage、sessionStorage、 indexedDB )<br>使用remote 不推荐用不好可能导致程序卡顿，性能不好</p><h4 id="经验-技巧">经验&amp;技巧</h4><p>少用remote模块  会触发底层的同步ipc事件，特别影响性能<br>不要用sync模式  可能导致程序卡死<br>在请求+响应的通信模式下，需要自定义超时限制</p><p>![image-20211206112648529](/Users/bytedance/Library/Application Support/typora-user-images/image-20211206112648529.png)</p><h4 id="使用-Electron-API-创建原生-GUI">使用 Electron API 创建原生 GUI</h4><p>BrowserWindow 应用窗口<br>Tray托盘<br>app iX Ïdock.badge<br>Menu菜单<br>dialog ESTE<br>TouchBar苹果触控栏…</p><h4 id="使用Electron-API获得底层能力">使用Electron API获得底层能力</h4><p>clipboard剪切板<br>globalShortcut 全局快捷键<br>desktopCapture捕获桌面<br>shell打开文件、URL…</p><h4 id="使用Node-js获得底层能力">使用Node.js获得底层能力</h4><p>Electron同时在主进程和渲染进程中对Node.js暴露了所有的接口<br>fs进行文件读写.<br>crypto进行加解密<br>通过npm安装即可引入社区上所有的Node.js库</p><h4 id="使用Node-js调用原生模块">使用Node.js调用原生模块</h4><p>node.js add-on<br>node-ffi (Foreign Function Interface)</p><h4 id="调用OS能力">调用OS能力</h4><p>WinRT(https:// <a href="http://github.com/">github.com/</a> NodeRT/NodeRT)<br>Applescript (https:ll <a href="http://github.com/TooTallNate/">github.com/TooTallNate/</a> node- applescript)<br>Shell (node.js child_ process)</p><p>![image-20211206113346000](/Users/bytedance/Library/Application Support/typora-user-images/image-20211206113346000.png)</p><h4 id="无兼容问题">无兼容问题</h4><p>不用担心在Safari、IE. 上的表现差异了大胆使用Chrome浏览器已经支持的API<br>babel中设置targets为Electron对应的Chrome版本</p><p>​ES 6/718/9/ 10高级语法 均可使用<br>​Async await / Promise<br>​String/Array/Object等高级用法<br>​BigInt</p><h4 id="无跨域问题">无跨域问题</h4><p>使用Node.js发送请求<br>使用Electron net发送请求</p><p>操作本地文件</p><p>更好用的本地db</p><p>多线程、多进程并行</p><p>实战，远程控制软件</p><p>![image-20211206114624981](/Users/bytedance/Library/Application Support/typora-user-images/image-20211206114624981.png)</p><h3 id="技术关键点">技术关键点</h3><h4 id="1-怎么捕获画面">1.怎么捕获画面?</h4><h5 id="Electron-desktopCapturer">Electron desktopCapturer</h5><p>desktopCapturer<br>通过[ navigator. mediaDevices. getUserMedia ] API，可以访问那些用于从桌面上捕获音频和视频的媒体源信息。<br>进程: Renderer</p><h4 id="2-怎么完成用户间连接、画面-指令传输">2.怎么完成用户间连接、画面+指令传输?</h4><p>WebRTC  客户端点对点连接方案<br>Web Real-Time Communications</p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20211206114842064.png" alt="image-20211206114842064" style="zoom:50%;" /><h4 id="3-怎么响应控制指令">3.怎么响应控制指令?</h4><p>robotjs(Node.js)  node的c++扩展，实现鼠标滚动点击等效果</p><h3 id="目录架构">目录架构</h3><p>common存放渲染进程、主进程可复用代码<br>前端框架在render/src/页面，构建产物在pages/页面<br>纯JS直接在Pages页面下</p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20211206115213602.png" alt="image-20211206115213602" style="zoom:50%;" /><h3 id="与React框架结合">与React框架结合</h3><h4 id="跟Electron在一起工作要做些什么呢">跟Electron在一起工作要做些什么呢?</h4><p>●书写React， 并且编译它。CRA其实-个好的选择。<br>●处理引入electron/node模块:<br>●Webpack配置: <a href="https://webpack.js.org/">https://webpack.js.org/</a> configuration/target/<br>●window.require<br>●Windows根据环境信息加载本地或者devServer url<br>●electron-is-dev<br>●启动命令适配。等到编译成功再启动ELectron<br>●concurently<br>●wait on</p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20211208114257411.png" alt="image-20211208114257411" style="zoom:33%;" /><p>如何捕获媒体流?<br>navigator.mediaDevices.getUserMedia ( MediaStreamConstraints)<br>返回: Promise, 成功后 resolve回调一个MediaStream 实例对象<br>参数: MediaStreamConstraints<br>. audio: Booleanl MediaTrackConstraints<br>. video: Boolean I MediaTrackConstraints<br>width: 分辨率<br>.    height:分辨率<br>.     frameRate: 帧率 比如{ideal:10,max:15}</p><p>例子：捕获音视频流媒体<br>navigator.mediaDevices.getUserMedia(l<br>audio: true,<br>video:{}<br>width:{min: 1024, ideal: 1280, max: 1920},<br>height: {min: 576, ideal: 720, max: 1080},<br>frameRate: {max: 30}<br>})</p><p>播放</p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20211208173636557.png" alt="image-20211208173636557" style="zoom:25%;" /><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20211208171916427.png" alt="image-20211208171916427" style="zoom: 50%;" /><p>![image-20211208173744544](/Users/bytedance/Library/Application Support/typora-user-images/image-20211208173744544.png)</p><p>![image-20211208201939841](/Users/bytedance/Library/Application Support/typora-user-images/image-20211208201939841.png)</p><p>![image-20211208202006331](/Users/bytedance/Library/Application Support/typora-user-images/image-20211208202006331.png)</p><p>![image-20211208205220046](/Users/bytedance/Library/Application Support/typora-user-images/image-20211208205220046.png)</p><p>![image-20211213154942433](/Users/bytedance/Library/Application Support/typora-user-images/image-20211213154942433.png)</p><p>![image-20211213155002883](/Users/bytedance/Library/Application Support/typora-user-images/image-20211213155002883.png)</p><p>![image-20211213155615937](/Users/bytedance/Library/Application Support/typora-user-images/image-20211213155615937.png)</p><p>![image-20211213180113502](/Users/bytedance/Library/Application Support/typora-user-images/image-20211213180113502.png)</p><p>![image-20211213205327123](/Users/bytedance/Library/Application Support/typora-user-images/image-20211213205327123.png)</p><p>![image-20211213205349930](/Users/bytedance/Library/Application Support/typora-user-images/image-20211213205349930.png)</p><p>![image-20211213205524224](/Users/bytedance/Library/Application Support/typora-user-images/image-20211213205524224.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 &lt;a href=&quot;https://www.chromium.org/&quot;&gt;Chromium&lt;/a&gt; 和 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node</summary>
      
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    
    <category term="electron" scheme="http://example.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>学习连接</title>
    <link href="http://example.com/2021/11/02/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%BF%9E%E6%8E%A5/"/>
    <id>http://example.com/2021/11/02/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-11-02T06:49:32.000Z</published>
    <updated>2021-11-02T07:29:49.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript">JavaScript</h2><h4 id="原生-js-系列">原生 js 系列</h4><p>冴羽大佬的这篇博客里，除了 undescore 的部分，你需要全部都能掌握。并且灵活的运用到开发中去。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog">JavaScript 深入系列、JavaScript 专题系列、ES6 系列</a></p><h4 id="完全熟练掌握-eventLoop。">完全熟练掌握 eventLoop。</h4><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules">tasks-microtasks-queues-and-schedules</a></p><h4 id="Promise">Promise</h4><ol><li>你需要阅读 Promise A+规范，注意其中的细节，并且灵活的运用到开发当中去。<br><a href="https://link.juejin.cn?target=http%3A%2F%2Fpromisesaplus.com">Promise A+ 英文文档</a></li><li>你需要跟着精品教程手写一遍 Promise，对里面的细节深入思考，并且把其中异步等待、错误处理等等细节融会贯通到你的开发思想里去。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxieranmaya%2Fblog%2Fissues%2F3">剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类</a></li><li>最后，对于 promise 的核心，异步的链式调用，你必须能写出来简化版的代码。<br><a href="https://juejin.im/post/5e6f4579f265da576429a907">最简实现 Promise，支持异步链式调用（20 行）</a></li></ol><p>题外话，当时精炼这 20 行真的绕了我好久 😂，但是搞明白了会有种恍然大悟的感觉。这种异步队列的技巧要融会贯通。</p><h4 id="async-await">async await</h4><p>对于 Promise 我们非常熟悉了，进一步延伸到 async await，这是目前开发中非常非常常用的异步处理方式，我们最好是熟悉它的 babel 编译后的源码。</p><p><a href="https://juejin.im/post/5e79e841f265da5726612b6e">手写 async await 的最简实现（20 行搞定）</a><br>babel 对于 async await 配合 generator 函数，做的非常巧妙，这里面的思想我们也要去学习，如何递归的处理一个串行的 promise 链？</p><p>这个技巧在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxios%2Faxios%2Fblob%2Fe50a08b2c392c6ce3b5a9dc85ebc860d50414529%2Flib%2Fcore%2FAxios.js%23L49-L62">axios 的源码</a>里也有应用。平常经常用的拦截器，本质上就是一串 promise 的串行执行。</p><p>当然，如果你还有余力的话，也可以继续深入的去看 generator 函数的 babel 编译源码。不强制要求，毕竟 generator 函数在开发中已经用的非常少了。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F102">ES6 系列之 Babel 将 Generator 编译成了什么样子</a></p><h4 id="异常处理">异常处理</h4><p>你必须精通异步场景下的错误处理，这是高级工程师必备的技能，如果开发中的异常被你写的库给吞掉了，那岂不是可笑。<br><a href="https://juejin.im/post/589036f8570c3500621a3be2">Callback Promise Generator Async-Await 和异常处理的演进</a></p><h4 id="插件机制">插件机制</h4><p>你需要大概理解前端各个库中的<code>插件</code>机制是如何实现的，在你自己开发一些库的时候也能融入自己适合的插件机制。<br><a href="https://juejin.im/post/5e13ea6a6fb9a0482b297e8e">Koa 的洋葱中间件，Redux 的中间件，Axios 的拦截器让你迷惑吗？实现一个精简版的就彻底搞懂了。</a></p><h4 id="设计模式">设计模式</h4><p>对于一些复杂场景，你的开发不能再是<code>if else</code>嵌套一把梭了，你需要把设计模式好好看一遍，在合适的场景下选择合适的设计模式。这里就推荐掘金小册吧，相信这篇小册会让你的<code>工程能力</code>得到质的飞跃，举例来说，在 Vue 的源码中就用到了<code>观察者模式</code>、<code>发布订阅模式</code>、<code>策略模式</code>、<code>适配器模式</code>、<code>发布订阅模式</code>、<code>工厂模式</code>、<code>组合模式</code>、<code>代理模式</code>、<code>门面模式</code>等等。</p><p>而这些设计模式如果你没学习过可能很难想到如何应用在工程之中，但是如果你学习过，它就变成了你内在的<code>工程能力</code>，往大了说，也可以是<code>架构能力</code>的一部分。</p><blockquote><p>在《设计模式》这本小册中我们提到过，即使是在瞬息万变的前端领域，也存在一些具备“一次学习，终生受用”特性的知识。从工程的角度看，我推荐大家着重学习的是设计模式。 -修言</p></blockquote><p>这里推荐掘金修言的<a href="https://link.juejin.cn?target=https%3A%2F%2Fp1-jj.byteimg.com%2Ftos-cn-i-t2oaga2asx%2Fgold-user-assets%2F2020%2F5%2F6%2F171e6247f6ea460a~tplv-t2oaga2asx-image.image">设计模式小册</a>。</p><h4 id="开发思想">开发思想</h4><p>有时候组合是优于继承的，不光是面向对象编程可以实现复用，在某些场景下，组合的思想可能会更加简洁优雅。</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fjavascript-scene%2Fmaster-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9">medium.com/javascript-…</a></p><blockquote><p>“…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong — “Coders at Work”</p></blockquote><blockquote><p>面向对象语言的问题在于它们带来了所有这些隐含的环境。 你想要一个香蕉，但你得到的是拿着香蕉和整个丛林的大猩猩。</p></blockquote><h4 id="代码规范">代码规范</h4><p>你需要熟读 clean-code-javascript，并且深入结合到日常开发中，结合你们小组的场景制定自己的规范。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbeginor%2Fclean-code-javascript">clean-code-javascript</a></p><h2 id="算法">算法</h2><p>算法这里我就不推荐各种小册，笔记，博文了。因为从我自己学习算法的经验来看，在没有太多的算法基础的情况下，文章基本上是很难真正的看进去并理解的，这里只推荐慕课网 bobo 老师的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcoding.imooc.com%2Fclass%2F82.html">LeetCode 真题课程</a>，在这个课程里算法大牛 bobo 老师会非常细心的把各个算法做成动图，由浅入深给你讲解各种分类的 LeetCode 真题。这是我最近学到的最有收获的一门课程了。</p><p>由于这门课程是 C++ 为主要语言的（不影响理解课程），我也针对此课程维护了一个对应的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsl1673495%2Fleetcode-javascript%2Fissues">JavaScript 版题解仓库</a>，在 Issue 里也根据标签分类整理了各个题型的讲解，欢迎 Star ✨。</p><p>算法对于前端来说重要吗？也许你觉得做题没用，但是我个人在做题后并且分门别类的整理好各个题型的思路和解法后，是能真切的感觉到自己的代码能力在飞速提高的。</p><p>对于很多觉得自己不够聪明，不敢去学习算法的同学来说，推荐 bobo 老师的这篇<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQvXIDpyrpiOmvEhcOUUmxQ">《天生不聪明》</a>，也正是这篇文章激励我开始了算法学习的旅程。</p><p>在这里列一下前端需要掌握的基础算法知识，希望能给你一个路线：</p><ol><li>算法的复杂度分析。</li><li>排序算法，以及他们的区别和优化。</li><li>数组中的双指针、滑动窗口思想。</li><li>利用 Map 和 Set 处理查找表问题。</li><li>链表的各种问题。</li><li>利用递归和迭代法解决二叉树问题。</li><li>栈、队列、DFS、BFS。</li><li>回溯法、贪心算法、动态规划。</li></ol><p>算法是底层的基础，把地基打扎实后，会让你在后续的职业生涯中大受裨益的。</p><p>这里也推荐我的整合文章 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsl1673495%2Fblogs%2Fissues%2F53">前端算法进阶指南</a>。</p><h2 id="框架篇">框架篇</h2><p>对于高级工程师来说，你必须要有一个你趁手的框架，它就像你手中的一把利剑，能够让你披荆斩棘，斩杀各种项目于马下。</p><p>下面我会分为<code>Vue</code>和<code>React</code>两个方面深入去讲。</p><h3 id="Vue">Vue</h3><p>Vue 方面的话，我主要是师从黄轶老师，跟着他认真走，基本上在 Vue 这方面你可以做到基本无敌。</p><h4 id="熟练运用">熟练运用</h4><ol><li>对于 Vue 你必须非常熟练的运用，官网的 api 你基本上要全部过一遍。并且你要利用一些高级的 api 去实现巧妙的封装。举几个简单的例子。</li><li>你要知道怎么用<code>slot-scope</code>去做一些数据和 ui 分离的封装。 以<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fposva%2Fvue-promised">vue-promised</a>这个库为例。 Promised 组件并不关注你的视图展示成什么样，它只是帮你管理异步流程，并且通过你传入的<code>slot-scope</code>，在合适的时机把数据回抛给你，并且帮你去展示你传入的视图。</li></ol><p class="code-caption" data-lang="vue" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-vue">&lt;template&gt;  &lt;Promised :promise=&quot;usersPromise&quot;&gt;    &lt;!-- Use the &quot;pending&quot; slot to display a loading message --&gt;    &lt;template v-slot:pending&gt;      &lt;p&gt;Loading...&lt;/p&gt;    &lt;/template&gt;    &lt;!-- The default scoped slot will be used as the result --&gt;    &lt;template v-slot=&quot;data&quot;&gt;      &lt;ul&gt;        &lt;li v-for=&quot;user in data&quot;&gt;&#123;&#123; user.name &#125;&#125;&lt;/li&gt;      &lt;/ul&gt;    &lt;/template&gt;    &lt;!-- The &quot;rejected&quot; scoped slot will be used if there is an error --&gt;    &lt;template v-slot:rejected=&quot;error&quot;&gt;      &lt;p&gt;Error: &#123;&#123; error.message &#125;&#125;&lt;/p&gt;    &lt;/template&gt;  &lt;/Promised&gt;&lt;/template&gt;复制代码</code></pre><ol><li>你需要熟练的使用<code>Vue.extends</code>，配合项目做一些<code>命令式api</code>的封装。并且知道它为什么可以这样用。（需要具备源码知识） <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsl1673495%2Fvue-netease-music%2Fblob%2Fmaster%2Fsrc%2Fbase%2Fconfirm.vue">confirm 组件</a></li></ol><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">export const confirm = function (text, title, onConfirm = () =&gt; &#123;&#125;) &#123;  if (typeof title === &quot;function&quot;) &#123;    onConfirm = title;    title = undefined;  &#125;  const ConfirmCtor = Vue.extend(Confirm);  const getInstance = () =&gt; &#123;    if (!instanceCache) &#123;      instanceCache = new ConfirmCtor(&#123;        propsData: &#123;          text,          title,          onConfirm,        &#125;,      &#125;);      // 生成dom      instanceCache.$mount();      document.body.appendChild(instanceCache.$el);    &#125; else &#123;      // 更新属性      instanceCache.text = text;      instanceCache.title = title;      instanceCache.onConfirm = onConfirm;    &#125;    return instanceCache;  &#125;;  const instance = getInstance();  // 确保更新的prop渲染到dom  // 确保动画效果  Vue.nextTick(() =&gt; &#123;    instance.visible = true;  &#125;);&#125;;复制代码</code></pre><ol><li>你要开始使用<code>JSX</code>来编写你项目中的复杂组件了，比如在我的网易云音乐项目中，我遇到了一个<a href="https://juejin.im/post/5d40fa605188255d2e32c929">复杂的音乐表格需求</a>，支持搜索文字高亮、动态隐藏列等等。<br>当然对于现在版本的 Vue，JSX 还是不太好用，有很多属性需要写嵌套对象，这会造成很多不必要的麻烦，比如没办法像 React 一样直接把外层组件传入的 props 透传下去，Vue3 的 rfc 中提到会把 vnode 节点的属性进一步扁平化，我们期待得到接近于 React 的完美 JSX 开发体验吧。</li><li>你要深入了解 Vue 中 nextTick 的原理，并且知道为什么要用微任务队列优于宏任务队列，结合你的 eventloop 知识深度思考。最后融入到你的<code>异步合并优化</code>的知识体系中去。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008589736">Vue 源码详解之 nextTick：MutationObserver 只是浮云，microtask 才是核心！</a></li><li>你要能理解 Vue 中的高阶组件。关于这篇文章中为什么 slot-scope 不生效的问题，你不能看他的文章讲解都一头雾水。（需要你具备源码知识）<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fp%2F1210000012743259%2Fread">探索 Vue 高阶组件 | HcySunYang</a></li><li>推荐一下我自己总结的 Vue 高阶组件文章，里面涉及到了一些进阶的用法。<br><a href="https://juejin.im/post/5e8b5fa6f265da47ff7cc139">Vue 进阶必学之高阶组件 HOC</a></li><li>对于 Vuex 的使用必须非常熟练，知道什么时候该用 Vuex，知道怎么根据需求去编写 Vuex 的 plugin，合理的去使用 Vuex 的 subscribe 功能完成一些全局维度的封装，比如我对于 Vuex 中 action 的错误处理懒得一个个去<code>try catch</code>，就封装了一个<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsl1673495%2Fvuex-error-plugin%2Fblob%2Fmaster%2Fplugin.js">vuex-error-plugin</a>。代码很简单，重要的是去理解为什么能这样做。这里用了 <code>monkey patch</code> 的做法，并不是很好的实践，仅以此作为引子。</li><li>对于 vue-router 的使用必须非常熟练，知道什么需求需要利用什么样的 router 钩子，这样才能 hold 住一个大型的项目，这个我觉得官方仓库里的进阶中文文档其实很好，不知道为什么好像没放在官网。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-router%2Ftree%2Fdev%2Fdocs%2Fzh%2Fguide%2Fadvanced">vue-router-advanced</a></li><li>理解虚拟 DOM 的本质，虚拟 DOM 一定比真实 DOM 更快吗？这篇是尤雨溪的回答，看完这个答案，相信你会对虚拟 DOM 有更进一步的认识和理解。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F31809713%2Fanswer%2F53544875">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？</a></li></ol><h4 id="源码深入">源码深入</h4><ol><li>你不光要熟练运用 Vue，由于 Vue 的源码写的非常精美，而且阅读难度不是非常大，很多人也选择去阅读 Vue 的源码。视频课这里推荐黄轶老师的 Vue 源码课程。这里也包括了 Vuex 和 vue-router 的源码。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fcoding.imooc.com%2Fclass%2F228.html">Vue.js 源码全方位深入解析 （含 Vue3.0 源码分析）</a></li><li>推荐 HcySunYang 大佬的 Vue 逐行分析，需要下载 git 仓库，切到 elegant 分支自己本地启动。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FHcySunYang%2Fvue-design">Vue 逐行级别的源码分析</a></li><li>当然，这个仓库的 master 分支也是宝藏，是这个作者的渲染器系列文章，脱离框架讲解了 vnode 和 diff 算法的本质<br><a href="https://link.juejin.cn?target=http%3A%2F%2Fhcysun.me%2Fvue-design%2Fzh%2Fessence-of-comp.html%23%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BA%A7%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88">组件的本质</a></li></ol><h4 id="Vue3-展望">Vue3 展望</h4><ol><li>Vue3 已经发布了 Beta 版本，你可以提前学习<code>Hook</code>相关的开发模式了。这里推荐一下我写的这篇 Vue3 相关介绍：</li></ol><p><a href="https://juejin.im/post/5e9ce011f265da47b8450c11">Vue3 究竟好在哪里？（和 React Hook 的详细对比）</a></p><h4 id="Vue3-源码">Vue3 源码</h4><p>对于响应式部分，如果你已经非常熟悉 Vue2 的响应式原理了，那么 Vue3 的响应式原理对你来说应该没有太大的难度。甚至在学习之中你会相互比较，知道 Vue3 为什么这样做更好，Vue2 还有哪部分需要改进等等。</p><p>Vue3 其实就是把实现换成了更加强大的 Proxy，并且把响应式部分做的更加的抽象，甚至可以，不得不说，Vue3 的响应式模型更加接近<code>响应式类库</code>的核心了，甚至<code>react-easy-state</code>等 React 的响应式状态管理库，也是用这套类似的核心做出来的。</p><p>再次强调，非常非常推荐学习 Vue3 的<code>@vue/reactivity</code>这个分包。</p><p>推一波自己的文章吧，细致了讲解了 Vue3 响应式的核心流程。</p><ol><li><a href="https://juejin.im/post/5e21196fe51d454d523be084">带你彻底搞懂 Vue3 的 Proxy 响应式原理！TypeScript 从零实现基于 Proxy 的响应式库。</a></li><li><a href="https://juejin.im/post/5e23b20f51882510073eb571">带你彻底搞懂 Vue3 的 Proxy 响应式原理！基于函数劫持实现 Map 和 Set 的响应式</a></li><li><a href="https://juejin.im/post/5e2fdf29e51d45026866107d">深度解析：Vue3 如何巧妙的实现强大的 computed</a></li></ol><p>在学习之后，我把<code>@vue/reactivity</code>包轻松的集成到了 React 中，做了一个状态管理的库，这也另一方面佐证了这个包的抽象程度：<br><a href="https://juejin.im/post/5e70970af265da576429aada">40 行代码把 Vue3 的响应式集成进 React 做状态管理</a></p><h3 id="React">React</h3><p>React 已经进入了 Hook 为主的阶段，社区的各个库也都在积极拥抱 Hook，虽然它还有很多陷阱和不足，但是这基本上是未来的方向没跑了。这篇文章里我会减少 class 组件的开发技巧的提及，毕竟好多不错的公司也已经全面拥抱 Hook 了。</p><h4 id="熟练应用">熟练应用</h4><ol><li><p>你必须掌握官网中提到的所有技巧，就算没有使用过，你也要大概知道该在什么场景使用。</p></li><li><p>推荐 React 小书，虽然书中的很多 api 已经更新了，但是核心的设计思想还是没有变<br><a href="https://link.juejin.cn?target=http%3A%2F%2Fhuziketang.mangojuice.top%2Fbooks%2Freact">React.js 小书</a></p></li><li><p>关于熟练应用，其实掘金的小册里有几个宝藏</p><ol><li><p>诚身大佬（悄悄告诉你，他的职级非常高）的企业级管理系统小册，这个项目里的代码非常深入，而且在抽象和优化方面也做的无可挑剔，自己抽象了<code>acl</code>权限管理系统和<code>router</code>路由管理，并且引入了<code>reselect</code>做性能优化，一年前我初次读的时候，很多地方懵懵懂懂，这一年下来我也从无到有经手了一套带<code>acl</code>和<code>权限路由</code>的管理系统后，才知道他的抽象能力有多强。真的是</p><blockquote><p>初闻不知曲中意，再闻已是曲中人。</p></blockquote><p><a href="https://juejin.im/book/5b1e15f76fb9a01e516d14a0">React 组合式开发实践：打造企业管理系统五大核心模块</a></p></li><li><p>三元大佬的 React Hooks 与 Immutable 数据流实战，深入浅出的带你实现一个音乐播放器。三元大家都认识吧？那是神，神带你们写应用项目，不学能说得过去吗？ <a href="https://juejin.im/book/5da96626e51d4524ba0fd237">React Hooks 与 Immutable 数据流实战</a></p></li></ol></li><li><p>深入理解 React 中的<code>key</code><br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Funderstanding-reacts-key-prop">understanding-reacts-key-prop</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F112917118">react 中为何推荐设置 key</a></p></li><li><p>React 官方团队成员对于<code>派生状态</code>的思考：<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fblog%2F2018%2F06%2F07%2Fyou-probably-dont-need-derived-state.html">you-probably-dont-need-derived-state</a></p></li></ol><h4 id="React-Hook">React Hook</h4><p>你必须熟练掌握 Hook 的技巧，除了官网文档熟读以外：</p><ol><li>推荐 Dan 的博客，他就是 Hook 的代码实际编写者之一，看他怎么说够权威了吧？这里贴心的送上汉化版。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F">useEffect 完整指南</a><br>看完这篇以后，进入<a href="https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2Fzh-hans">dan 的博客主页</a>，找出所有和 Hook 有关的，全部精读！</li><li>推荐黄子毅大佬的精读周刊系列<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdt-fe%2Fweekly%2Fblob%2Fv2%2F096.%E7%B2%BE%E8%AF%BB%E3%80%8AuseEffect%20%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E3%80%8B.md">096.精读《useEffect 完全指南》.md</a><br>注意！不是只看这一篇，而是这个仓库里所有有关于 React Hook 的文章都去看一遍，结合自己的思想分析。</li><li>Hook 陷阱系列 还是 Dan 老哥的文章，详细的讲清楚了所谓<code>闭包陷阱</code>产生的原因和设计中的权衡。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fhow-are-function-components-different-from-classes%2F">函数式组件与类组件有何不同？</a></li><li>去找一些社区的精品自定义 hook，看看他们的开发和设计思路，有没有能融入自己的日常开发中去的。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000020964640">精读《Hooks 取数 - swr 源码》</a><br><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F103150605%3Futm_source%3Dwechat_session">Umi Hooks - 助力拥抱 React Hooks</a><br><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F106665408">React Hooks 的体系设计之一 - 分层</a></li></ol><h4 id="React-性能优化">React 性能优化</h4><p>React 中优化组件重渲染，这里有几个隐含的知识点。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Foptimize-react-re-renders">optimize-react-re-renders</a></p><p>如何对 React 函数式组件进行性能优化？这篇文章讲的很详细，值得仔细阅读一遍。 <a href="https://juejin.im/post/5dd337985188252a1873730f">如何对 React 函数式组件进行优化</a></p><h4 id="React-单元测试">React 单元测试</h4><ol><li>使用<code>@testing-library/react</code>测试组件，这个库相比起 enzyme 更好的原因在于，它更注重于<strong>站在用户的角度</strong>去测试一个组件，而不是测试这个组件的<strong>实现细节</strong>。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fintroducing-the-react-testing-library">Introducing The React Testing Library</a><br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Ftesting-implementation-details">Testing Implementation Details</a></li><li>使用<code>@testing-library/react-hooks</code>测试自定义 Hook<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fhow-to-test-custom-react-hooks">how-to-test-custom-react-hooks</a></li></ol><h4 id="React-和-TypeScript-结合使用">React 和 TypeScript 结合使用</h4><ol><li>这个仓库非常详细的介绍了如何把 React 和 TypeScript 结合，并且给出了一些进阶用法的示例，非常值得过一遍！<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftypescript-cheatsheets%2Freact-typescript-cheatsheet">react-typescript-cheatsheet</a></li><li>这篇文章是蚂蚁金服数据体验技术部的同学带来的，其实除了这里面的技术文章以外，蚂蚁金服的同学也由非常生动给我们讲解了一个高级前端同学是如何去社区寻找方案，如何思考和落地到项目中的，由衷的佩服。<br><a href="https://juejin.im/post/5dccc9b8e51d4510840165e2">React + Typescript 工程化治理实践</a></li><li>微软的大佬带你写一个类型安全的组件，非常深入，非常过瘾…<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.andrewbran.ch%2Fpolymorphic-react-components%2F">Writing Type-Safe Polymorphic React Components (Without Crashing TypeScript)</a></li><li>React + TypeScript 10 个需要避免的错误模式。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40martin_hotell%2F10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680">10-typescript-pro-tips-patterns-with-or-without-react</a></li></ol><h4 id="React-代码抽象思考">React 代码抽象思考</h4><ol><li>何时应该把代码拆分为组件？<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fwhen-to-break-up-a-component-into-multiple-components">when-to-break-up-a-component-into-multiple-components</a></li><li>仔细思考你的 React 应用中，状态应该放在什么位置，是组件自身，提升到父组件，亦或是局部 context 和 redux，这会有益于提升应用的性能和可维护性。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fstate-colocation-will-make-your-react-app-faster%2F">state-colocation-will-make-your-react-app-faster</a></li><li>仔细思考 React 组件中的状态应该如何管理，优先使用派生状态，并且在适当的时候利用 useMemo、reselect 等库去优化他们。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fdont-sync-state-derive-it">dont-sync-state-derive-it</a></li><li>React Hooks 的自定义 hook 中，如何利用 reducer 的模式提供更加灵活的数据管理，让用户拥有数据的控制权。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fthe-state-reducer-pattern-with-react-hooks">the-state-reducer-pattern-with-react-hooks</a></li></ol><h2 id="TypeScript">TypeScript</h2><p>自从 Vue3 横空出世以来，TypeScript 好像突然就火了。这是一件好事，推动前端去学习强类型语言，开发更加严谨。并且第三方包的 ts 类型支持的加入，让我们甚至很多时候都不再需要打开文档对着 api 撸了。</p><p>关于 TypeScript 学习，其实几个月前我还对于这门 JavaScript 的超集一窍不通，经过两三个月的静心学习，我能够去理解一些相对复杂的类型了，</p><p>可以说 TypeScript 的学习和学一个库或者学一个框架是完全不同的，</p><h4 id="入门">入门</h4><ol><li>除了官方文档以外，还有一些比较好的中文入门教程。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhongsp.gitbooks.io%2Ftypescript-handbook%2Fcontent%2F">TypeScript Handbook 入门教程 </a></li><li>TypeScript Deep Dive 非常高质量的英文入门教学。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fbasarat.gitbook.io%2Ftypescript%2Ftype-system">TypeScript Deep Dive</a></li><li>工具泛型在日常开发中都非常的常用，必须熟练掌握。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F40311981">TS 一些工具泛型的使用及其实现</a></li><li>视频课程，还是黄轶大佬的，并且这个课程对于单元测试、前端手写框架、以及网络请求原理都非常有帮助。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fcoding.imooc.com%2Fclass%2F330.html">基于 TypeScript 从零重构 axios</a></li></ol><h4 id="进阶">进阶</h4><ol><li>这五篇文章里借助非常多的案例，为我们讲解了 ts 的一些高级用法，请务必反复在 ide 里尝试，理解，不懂的概念及时回到文档中补习。<br><a href="https://juejin.im/post/5c8a518ee51d455e4d719e2e">巧用 TypeScript 系列 一共五篇</a></li><li>TS 进阶非常重要的一点，条件类型，很多泛型推导都需要借助它的力量。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fmariusschulz.com%2Fblog%2Fconditional-types-in-typescript">conditional-types-in-typescript</a></li><li>以及上面那个大佬博客中的所有 TS 文章。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fmariusschulz.com">mariusschulz.com</a></li></ol><h4 id="实战">实战</h4><ol><li>一个参数简化的实战，涉及到的高级知识点非常多。<ol><li>🎉TypeScript 的高级类型（Advanced Type）</li><li>🎉Conditional Types (条件类型)</li><li>🎉Distributive conditional types (分布条件类型)</li><li>🎉Mapped types（映射类型）</li><li>🎉 函数重载<br><a href="https://juejin.im/post/5e38dd65518825492b509dd6">TypeScript 参数简化实战</a></li></ol></li><li>实现一个简化版的 Vuex，同样知识点结合满满。<ol><li>🎉TypeScript 的高级类型（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fadvanced-types.html">Advanced Type</a>）</li><li>🎉TypeScript 中利用泛型进行反向类型推导。(<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fgenerics.html">Generics</a>)</li><li>🎉Mapped types（映射类型）</li><li>🎉Distributive Conditional Types（条件类型分配）</li><li>🎉TypeScript 中 Infer 的实战应用（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-next%2Fblob%2F985f4c91d9d3f47e1314d230c249b3faf79c6b90%2Fpackages%2Freactivity%2Fsrc%2Fref.ts%23L89">Vue3 源码里 infer 的一个很重要的使用</a>）<br><a href="https://juejin.im/post/5e38dd65518825492b509dd6">TS 实现智能类型推导的简化版 Vuex</a></li></ol></li></ol><h4 id="刻意训练">刻意训练</h4><p>它几乎是一门新的语言（在类型世界里来说），需要你花费很大的精力去学好它。</p><p>我对于 TypeScript 的学习建议其实就是一个关键词：<code>刻意训练</code>，在过基础概念的时候，不厌其烦的在<code>vscode</code>中敲击，理解，思考。在基础概念过完以后去寻找实践文章，比如我上面<code>进阶</code>和<code>实战</code>部分推荐的几篇，继续<code>刻意训练</code>，一定要堆积代码量，学习一门新的语言是不可能靠看文档获得成功的。</p><p>我会建立一个仓库，专门记录我遇到的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsl1673495%2Ftypescript-codes">TypeScript 的有趣代码</a>，自己动手敲一遍，并且深入理解。</p><h4 id="能力分级">能力分级</h4><p>其实 TypeScript 的能力也是两级分化的，日常写业务来说，你定义一些 interface，配合 React.FC 这种官方内置的类型也就跑通了，没什么特别难的点。</p><p>但是如果是造轮子呢？如果你自己写了一个工具库，并且类型比较复杂，你能保证推导出来吗？亦或者就拿 Vue3 来说，ref 是一个很复杂的嵌套类型，</p><p>假如我们这样定义一个值<code>const value = ref(ref(2))</code>，对于嵌套的 ref，Vue3 会做一层<code>拆包</code>，也就是说其实<code>ref.value</code>会是 2，</p><p>那么它是如何让 ts 提示出 value 的类型是 number 的呢？</p><p>如果你看到源码里的这段代码，你只有基础的话，保证懵逼。<br><a href="https://juejin.im/post/5e94595c6fb9a03c341daa75">Vue3 跟着尤雨溪学 TypeScript 之 Ref 类型从零实现</a></p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">// Recursively unwraps nested value bindings.export type UnwrapRef&lt;T&gt; = &#123;  cRef: T extends ComputedRef&lt;infer V&gt; ? UnwrapRef&lt;V&gt; : T  ref: T extends Ref&lt;infer V&gt; ? UnwrapRef&lt;V&gt; : T  array: T  object: &#123; [K in keyof T]: UnwrapRef&lt;T[K]&gt; &#125;&#125;[T extends ComputedRef&lt;any&gt;  ? 'cRef'  : T extends Array&lt;any&gt;    ? 'array'    : T extends Ref | Function | CollectionTypes | BaseTypes      ? 'ref' // bail out on types that shouldn't be unwrapped      : T extends object ? 'object' : 'ref']复制代码</code></pre><h5 id="业务开发人员">业务开发人员</h5><p>如果短期内你对自己的要求是能上手业务，那么你理解 TypeScript 基础的<code>interface</code>和<code>type</code>编写和泛型的普通使用（可以理解为类型系统里的函数传参）也已经足够。</p><h5 id="框架开发人员">框架开发人员</h5><p>但是长期来看，如果你的目的是能够自己编写一些类型完善的库或框架，或者说你在公司扮演<code>前端架构师</code>、<code>轮子专家</code>等等角色，经常需要写一些偏底层的库给你的小伙伴们使用，那么你必须深入学习，这样才能做到给你的框架使用用户完美的类型体验。</p><h4 id="面试题">面试题</h4><p>TypeScript 相关的面试题我见得不多，不过<code>力扣中国</code>的面试题算是难度偏高的，其中有一道 TS 的面试题，可以说是实用性和难度都有所兼顾，简单来说就是解包。</p><p class="code-caption" data-lang="ts" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-ts">// 解开参数和返回值中的PromiseasyncMethod&lt;T, U&gt;(input: Promise&lt;T&gt;): Promise&lt;Action&lt;U&gt;&gt; ↓asyncMethod&lt;T, U&gt;(input: T): Action&lt;U&gt;// 解开参数中的ActionsyncMethod&lt;T, U&gt;(action: Action&lt;T&gt;): Action&lt;U&gt; ↓syncMethod&lt;T, U&gt;(action: T): Action&lt;U&gt;复制代码</code></pre><p>我在高强度学习了两三个月 TS 的情况下，已经能把这道题目相对轻松的解出来，相信这也是说明我的学习路线没有走偏（题解就不放了，尊重面试题，其实就是考察了<code>映射类型</code>和<code>infer</code>的使用）。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLeetCode-OpenSource%2Fhire%2Fblob%2Fmaster%2Ftypescript_zh.md">力扣面试题</a></p><h2 id="代码质量">代码质量</h2><h4 id="代码风格">代码风格</h4><ol><li>在项目中集成 Prettier + ESLint + Airbnb Style Guide <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.echobind.com%2Fintegrating-prettier-eslint-airbnb-style-guide-in-vscode-47f07b5d7d6a">integrating-prettier-eslint-airbnb-style-guide-in-vscode</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Flevelup.gitconnected.com%2Fsetting-up-eslint-with-prettier-typescript-and-visual-studio-code-d113bbec9857">在项目中集成 ESLint with Prettier, TypeScript</a></li></ol><h4 id="高质量架构">高质量架构</h4><ol><li>如何重构一个过万 Star 开源项—BetterScroll，是由滴滴的大佬<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftheniceangel">嵇智</a>所带来的，无独有偶的是，这篇文章除了详细的介绍一个合格的开源项目应该做到的代码质量保证，测试流程，持续集成流程以外，也体现了他的一些思考深度，非常值得学习。<br><a href="https://juejin.im/post/5e40f72df265da5732551bdf">如何重构一个过万 Star 开源项目—BetterScroll</a></li></ol><h4 id="Git-提交信息">Git 提交信息</h4><ol><li><p>很多新手在提交 Git 信息的时候会写的很随意，比如<code>fix</code>、<code>test</code>、<code>修复</code>，这么糊弄的话是会被 leader 揍的！</p><p>[<a href="https://link.juejin.cn?target=https%3A%2F%2Fjiongks.name%2Fblog%2Fgit-commit">译]如何撰写 Git 提交信息</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fc7e40dab5b05">Git-Commit-Log 规范（Angular 规范）</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fcommitizen">commitizen</a>规范流程的 commit 工具，规范的 commit 格式也会让工具帮你生成友好的<code>changelog</code></p></li></ol><h2 id="构建工具">构建工具</h2><ol><li>webpack 基础和优化<br><a href="https://link.juejin.cn?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F">深入浅出 webpack</a></li><li>滴滴前端工程师的 webpack 深入源码分析系列，非常的优秀。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDDFE%2FDDFE-blog%2Fissues%2F36">webpack 系列之一总览</a></li><li>字节跳动范文杰的 webpack 原理系列：[<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F363928061">万字总结] 一文吃透 Webpack 核心原理</a></li></ol><h2 id="性能优化">性能优化</h2><ol><li>推荐修言大佬的<a href="https://link.juejin.cn?target=https%3A%2F%2Fp1-jj.byteimg.com%2Ftos-cn-i-t2oaga2asx%2Fgold-user-assets%2F2020%2F5%2F6%2F171e625d5fe327af~tplv-t2oaga2asx-image.image">性能优化小册</a>，这个真的是讲的深入浅出，从<code>webpack</code>到<code>网络</code>到<code>dom操作</code>，全方位的带你做一些性能优化实战。这本小册我当时看的时候真的是完全停不下来，修言大佬的风格既轻松又幽默。但是讲解的东西却能让你受益匪浅。</li><li>谷歌开发者性能优化章节，不用多说了吧？很权威了。左侧菜单栏里还有更多相关内容，可以按需选择学习。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fuser-centric-performance-metrics">user-centric-performance-metrics</a></li><li>详谈合成层，合成层这个东西离我们忽远忽近，可能你的一个不小心的操作就造成<code>层爆炸</code>，当然需要仔细关注啦。起码，在性能遇到瓶颈的时候，你可以打开 chrome 的<code>layer</code>面板，看看你的页面到底是怎么样的一个层分布。<br><a href="https://juejin.im/entry/59dc9aedf265da43200232f9">详谈层合成（composite）</a></li><li>刘博文大佬的性能优化指南，非常清晰的讲解了网页优化的几个重要的注意点。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F66398148">让你的网页更丝滑</a></li></ol><h2 id="社区讨论">社区讨论</h2><p>作为一个合格的前端工程师，一定要积极的深入社区去了解最新的动向，比如在<code>twitter</code>上关注你喜欢的技术开发人员，如 Dan、尤雨溪。</p><p>另外 Github 上的很多 issue 也是宝藏讨论，我就以最近我对于 Vue3 的学习简单的举几个例子。</p><h4 id="为什么-Vue3-不需要时间切片？">为什么 Vue3 不需要时间切片？</h4><p>尤雨溪解释关于为什么在 Vue3 中不加入 React 时间切片功能？并且详细的分析了 React 和 Vue3 之间的一些细节差别，狠狠的吹了一波 Vue3（爱了爱了）。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Frfcs%2Fissues%2F89">Why remove time slicing from vue3?</a></p><h4 id="Vue3-的composition-api到底好在哪？">Vue3 的<code>composition-api</code>到底好在哪？</h4><p>Vue3 的 functional-api 相关的 rfc，尤大舌战群儒，深入浅出的为大家讲解了 Vue3 的设计思路等等。<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Frfcs%2Fissues%2F63">Amendment proposal to Function-based Component API</a></p><h4 id="Vue3composition-api的第一手文档">Vue3<code>composition-api</code>的第一手文档</h4><p>vue-composition-api 的 rfc 文档，在国内资料还不齐全的情况下，我去阅读了<br><a href="https://link.juejin.cn?target=https%3A%2F%2Fvue-composition-api-rfc.netlify.com%2F%23summary">vue-composition-api-rfc</a> 英文版文档，对于里面的设计思路叹为观止，学到了非常非常多尤大的思想。</p><p>总之，对于你喜欢的仓库，都可以去看看它的 issue 有没有看起来感兴趣的讨论，你也会学到非常多的东西。并且你可以和作者保持思路上的同步，这是非常难得的一件事情。</p><h4 id="关于-Hook-的一些收获">关于 Hook 的一些收获</h4><p>我在狠狠的吸收了一波尤大对于 Vue3 <code>composition-api</code>的设计思路的讲解，新旧模式的对比以后，这篇文章就是我对 Vue3 新模式的一些见解。<br><a href="https://juejin.im/post/5e0da5606fb9a048483ecf64">Vue3 Composition-Api + TypeScript + 新型状态管理模式探索。</a></p><p>在 Vue2 里，可以通过<code>plugin</code>先体验<code>composition-api</code>，截取这篇文章对应的实战项目中的一小部分代码吧：</p><p class="code-caption" data-lang="vue" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-vue">&lt;template&gt;  &lt;Books :books=&quot;booksAvaluable&quot; :loading=&quot;loading&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; createComponent &#125; from '@vue/composition-api';import Books from '@/components/Books.vue';import &#123; useAsync &#125; from '@/hooks';import &#123; getBooks &#125; from '@/hacks/fetch';import &#123; useBookListInject &#125; from '@/context';export default createComponent(&#123;  name: 'books',  setup() &#123;    const &#123; books, setBooks, booksAvaluable &#125; = useBookListInject();    const loading = useAsync(async () =&gt; &#123;      const requestBooks = await getBooks();      setBooks(requestBooks);    &#125;);    return &#123; booksAvaluable, loading &#125;;  &#125;,  components: &#123;    Books,  &#125;,&#125;);&lt;/script&gt;&lt;style&gt;.content &#123;  max-width: 700px;  margin: auto;&#125;&lt;/style&gt;复制代码</code></pre><p>本实战对应仓库：</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsl1673495%2Fvue-bookshelf">vue-bookshelf</a></p><p>并且由于它和<code>React Hook</code>在很多方面的思想也非常相近，这甚至对于我在<code>React Hook</code>上的使用也大有裨益，比如代码组织的思路上，</p><p>在第一次使用<code>Hook</code>开发的时候，大部分人可能还是会保留着以前的思想，把<code>state</code>集中起来定义在代码的前一大段，把<code>computed</code>集中定义在第二段，把<code>mutation</code>定义在第三段，如果不看尤大对于设计思想的讲解，我也一直是在这样做。</p><p>但是为什么 Logical Concerns 优于 Vue2 和 React Class Component 的 Option Types？看完<a href="https://link.juejin.cn?target=https%3A%2F%2Fvue-composition-api-rfc.netlify.com%2F%23detailed-design">detailed-design</a>这个章节你就全部明白了，并且这会融入到你日常开发中去。</p><p>总之，看完这篇以后，我果断的把公司里的首屏组件的一坨代码直接抽成了 n 个自定义 hook，维护效率提升简直像是坐火箭。</p><p>当然，社区里的宝藏 issue 肯定不止这些，我只是简单的列出了几个，但就是这几个都让我的技术视野开阔了很多，并且是真正的融入到公司的业务实战中去，是<code>具有业务价值</code>的。希望你养成看 issue，紧跟英文社区的习惯，Github issue 里单纯的技术探讨氛围，真的是国内很少有社区可以媲美的。</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">function AppInner(&#123; children &#125;) &#123;  const [menus, setMenus] = useState(&#123;&#125;);  // 用户信息  const user = useUser();  // 主题能力  useTheme();  // 权限获取  useAuth(&#123;    setMenus,  &#125;);  // 动态菜单也需要用到菜单的能力  useDynamicMenus(&#123;    menus,    setMenus,  &#125;);  return (    &lt;Context.Provider value=&#123;user&#125;&gt;      &lt;Layout routers=&#123;backgrounds&#125;&gt;&#123;children&#125;&lt;/Layout&gt;    &lt;/Context.Provider&gt;  );&#125;复制代码</code></pre><p>可以看到，<code>Hook</code>在代码组织的方面有着得天独厚的优势，甚至各个<code>模块</code>之间值的传递都是那么的自然，仅仅是函数传参而已。<br>总之，社区推出一些新的东西，它总归是解决了之前的一些痛点。我们跟着大佬的思路走，一定有肉吃。</p><h4 id="Tree-Shaking-的-Issue">Tree Shaking 的 Issue</h4><p>相学长的文章<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F32831172">你的 Tree-Shaking 并没什么卵用</a>中，也详细的描述了他对于<code>副作用</code>的一些探寻过程，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmishoo%2FUglifyJS2%2Fissues%2F1261">UglifyJS 的 Issue</a>中找到了最终的答案，然后贡献给中文社区，这些内容最开始不会在任何中文社区里出现，只有靠你去探寻和发现。</p><h2 id="学习方法的转变">学习方法的转变</h2><p>从初中级前端开始往高级前端进阶，有一个很重要的点，就是很多情况下国内社区能找到的资料已经不够用了，而且有很多优质资料也是从国外社区二手、三手翻译过来的，翻译质量也不能保证。</p><p>这就引申出我们进阶的第一个点，<strong>开始接受英文资料</strong>。</p><p>这里很多同学说，我的英文能力不行啊，看不懂。其实我想说，笔者的英语能力也很一般，从去年开始我立了个目标，就是带着划词翻译插件也要开始艰难的看英文文章和资料，遇到不懂的单词就划出来看两眼（没有刻意去背），第五六次遇见这个单词的时候，就差不多记得它是什么意思了。</p><p>半年左右的时间下来，（大概保持每周 3 篇以上的阅读量）能肉眼可见的感觉自己的英语能力在进步，很多时候不用划词翻译插件，也可以完整的阅读下来一段文章。</p><p>这里是我当时阅读英文优质文章的一些记录，</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsl1673495%2Fblogs%2Fissues%2F15">英文技术文章阅读</a></p><p>后面英文阅读慢慢成了一件比较自然的事情，也就没有再刻意去记录，前期可以用这种方式激励自己。</p><p>推荐两个英文站点吧，有很多高质量的前端文章。</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdev.to%2Ft%2Fjavascript">dev.to</a><br><a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com">medium</a></p><p>medium 可能需要借助一些科学工具才能查看，但是里面的会员付费以及作者激励机制使得文章非常的优质。登录自己的谷歌账号即可成为会员，前期可能首页不会推荐一些前端相关的文章，你可以自己去搜索关键字如<code>Vue</code>、<code>React</code>、<code>Webpack</code>，任何你兴趣的前端技术栈，不需要过多久你的首页就会出现前端的推荐内容。好好享受这个高质量的英文社区吧。</p><h2 id="关于实践">关于实践</h2><p>社区有很多大佬实力很强，但是对新手写的代码嗤之以鼻，认为有 <code>any</code> 的就不叫 <code>TypeScript</code>、认为没有<code>单元测试</code>就没资格丢到 Github 上去。这种言论其实也不怪他们，他们也只是对开源软件的要求高到偏执而已。但是对于新手学习来说，这种言论很容易对大家造成打击，导致不敢写 ts，写的东西不敢放出来。其实大可不必，<code>工业聚</code> 对于这些观点就发表了一篇很好的看法，让我觉得深受打动，也就是这篇文章开始，我慢慢的把旧项目用 ts 改造起来，慢慢的进步。</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA4Njc2MTE3Ng%3D%3D%26mid%3D2456151423%26idx%3D1%26sn%3D2fec2ff0606b865abaaaaea48ddfd167%26chksm%3D88528ec8bf2507de91cec62b4bad281fb8bf6d16c8a1ea04ea3fedb871099dfb7fda42082fff%26mpshare%3D1%26scene%3D1%26srcid%3D%26sharer_sharetime%3D1585884823115%26sharer_shareid%3D82384198865aad802052fa45394cd852%23rd">Vue 3.0 公开代码之后……</a></p><h2 id=""></h2><p>作者：ssh_晨曦时梦见兮<br>链接：<a href="https://juejin.cn/post/6844904103504527374">https://juejin.cn/post/6844904103504527374</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="1-基础拾遗">1. 基础拾遗</h2><blockquote><p>温故而知新，不知则习之，是以牢固根基。</p></blockquote><h3 id="1-1-JavaScript">1.1. JavaScript</h3><ul><li>[You-Dont-Know-JS <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS">英]</a></li><li>JavaScript 基础运行机制：<ul><li>[JS 引擎、运行时与调用栈概述 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-does-javascript-actually-work-part-1-b0bacc073cf">英]</a></li><li>[V8 引擎简介 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e">英]</a></li><li>[内存管理与4中常见的泄漏 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec">英]</a></li></ul></li><li>Event Loop（面试里总会有一题 Event Loop…）：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5">从 Event Loop 规范探究 JavaScript 异步及浏览器更新渲染时机</a></li><li>[异步之 Event Loop <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5">英]</a></li><li>[NodeJS 中的 Event Loop、Timers 与 <code>process.nextTick()</code> <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fen%2Fdocs%2Fguides%2Fevent-loop-timers-and-nexttick%2F">英]</a></li><li>[Tasks、Microtasks、Queues 与Schedules <a href="https://link.juejin.cn?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F">英]</a></li></ul></li><li>[Web Workers 及其5个常见使用场景 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a">英]</a></li><li>[如何避免 async/await 地狱 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.freecodecamp.org%2Favoiding-the-async-await-hell-c77a0fb71c4c">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fbc7b8d542dcd">“回调地狱”的解决思路汇总</a></li></ul><h3 id="1-2-CSS">1.2. CSS</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Flhammer.cn%2FYou-need-to-know-css%2F%23%2F">You-Need-to-Know-CSS</a></li><li><a href="https://juejin.cn/post/6844903634849759239">CSS布局指南</a></li><li>[CSS 中的各类换行处理方式 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fwhere-lines-break-is-complicated-heres-all-the-related-css-and-html%2F">英]</a>：处理经典的换行问题</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F264372456">浏览器将rem转成px时有精度误差怎么办？</a></li><li><a href="https://juejin.cn/post/6844903681008074765">精准操控的滚动体验，浅谈新标准 Scroll Snap</a></li><li>[如何完美实现一个非<code>button</code>元素的按钮 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.scottohara.me%2Fblog%2F2018%2F10%2F03%2Funbutton-buttons.html">英]</a></li><li>[巧用 CSS Grid 来创建横向滚动容器 <a href="https://link.juejin.cn?target=https%3A%2F%2Fuxdesign.cc%2Fcreating-horizontal-scrolling-containers-the-right-way-css-grid-c256f64fc585">英]</a></li><li>[如何处理内联元素中的空隙 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Ffighting-the-space-between-inline-block-elements%2F">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000002783265">CSS Stacking Context 里那些鲜为人知的坑</a></li></ul><h3 id="1-3-浏览器">1.3. 浏览器</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F">浏览器的工作原理</a></li><li>现代浏览器内部是如何运行的：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part1">Chrome浏览器概览</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part2">浏览时发生了什么？</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part3">渲染进程的内部工作原理</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part4">compositor是如何来提高交互性能的？</a></li></ul></li><li>[完整的页面生命周期 API 介绍 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F07%2Fpage-lifecycle-api">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zeolearn.com%2Fmagazine%2Fdifferent-types-of-observers-supported-by-modern-browsers">四个新的观察者：Intersection / Mutation / Resize / Performance (Observer)</a></li><li>[渲染引擎工作方式及优化建议 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance-7b95553baeda">英]</a></li><li><a href="https://juejin.cn/post/6844903687601520647">浏览器内核渲染：重建引擎</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F438183ddcea8">跨域解决方案汇总</a></li></ul><h2 id="2-工程化与工具">2. 工程化与工具</h2><blockquote><p>软件规模的扩大带来了工程化的需求，前端也不例外。随着 NodeJS 的出现，前端工程师可以使用熟悉的 JS 快速开发所需的工具。工具链生态的繁荣也是前端圈繁荣的一个写照。</p></blockquote><h3 id="2-1-webpack">2.1. webpack</h3><ul><li>[webpack 中的 Chunk 关系图算法 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fwebpack%2Fthe-chunk-graph-algorithm-week-26-29-7c88aa5e4b4e">英]</a></li><li><a href="https://juejin.cn/post/6844903693070909447#heading-13">webpack 进阶系列文章</a></li><li>编译优化：<ul><li>[如何提升大型项目中 webpack 的性能 🎥 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DAifDI71uqF0">英]</a></li><li>[运行时优化：Separating a Manifest <a href="https://link.juejin.cn?target=https%3A%2F%2Fsurvivejs.com%2Fwebpack%2Foptimizing%2Fseparating-manifest">英]</a></li><li>[在 webpack 中使用  <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fwebpack%2Flink-rel-prefetch-preload-in-webpack-51a52358f84c">英]</a></li><li><a href="https://juejin.cn/post/6844903669100445710">如何更好使用 webpack tree-shaking</a></li></ul></li><li>关于 webpack 编译缓存的讨论：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack%2Fissues%2F250%23issuecomment-240643985">mzgoddard’s comment</a></li><li>[<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack%2Fissues%2F6527">spec: webpack 5] - A module disk cache between build processes</a></li></ul></li></ul><h3 id="2-2-Gulp">2.2. Gulp</h3><ul><li>[Gulp 4 简介 <a href="https://link.juejin.cn?target=https%3A%2F%2Ffettblog.eu%2Fgulp-4-parallel-and-series%2F">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F35571124770f">基于Gulp的多页面应用实践指南</a></li></ul><h3 id="2-3-Linter">2.3. Linter</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34656263">JS Linter 进化史</a></li><li>[为何要在项目汇总使用 ESLint <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fthe-node-js-collection%2Fwhy-and-how-to-use-eslint-in-your-project-742d0bc61ed7">英]</a></li></ul><h3 id="2-4-静态类型（Typescript-Flow）">2.4. 静态类型（Typescript/Flow）</h3><ul><li>[Typescript 总体架构 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMicrosoft%2FTypeScript%2Fwiki%2FArchitectural-Overview">英]</a></li><li>为什么要在 JavaScript 中进行静态类型检查：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fbda750e2d15e">第一部分</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F289b3c734a9f">第二、三部分</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd23f93be8821">第四部分</a></li></ul></li></ul><h3 id="2-5-Babel">2.5. Babel</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fuser-handbook.md">Babel 用户手册</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md">Babel 插件手册</a></li></ul><h3 id="2-6-CSS预处理与模块化">2.6. CSS预处理与模块化</h3><ul><li>[CSS 进化史 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40perezpriego7%2Fcss-evolution-from-css-sass-bem-css-modules-to-styled-components-d4c1da3a659b">英]</a></li><li><a href="https://juejin.cn/post/6844903620261969934">CSS 模块化方案系列</a></li></ul><h2 id="3-性能优化">3. 性能优化</h2><blockquote><p>性能优化其实就是在理解浏览器的基础上“因地制宜”，因此可以配合1.3节“浏览器”部分进行理解。</p></blockquote><p>强烈推荐把 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fwhy-performance-matters%2F">Google Web 上性能优化</a> Tab 中的文章都通读一遍，其基本涵盖了现代浏览器中性能优化的所有点，非常系统。下面也摘录了其中一些个人认为非常不错的篇幅。</p><h3 id="3-1-加载性能">3.1. 加载性能</h3><ul><li>[PRPL 模式 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fprpl-pattern%2F">英]</a></li><li>[图片懒加载完全指南 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fthe-complete-guide-to-lazy-loading-images">英]</a></li><li>[使用 Intersection Observer 来懒加载图片 <a href="https://link.juejin.cn?target=http%3A%2F%2Fdeanhume.com%2Flazy-loading-images-using-intersection-observer%2F">英]</a></li><li>[图片与视频懒加载的详细指南 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Flazy-loading-guidance%2Fimages-and-video%2F">英]</a></li><li>[使用 Application Shell 架构来实现秒开应用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2015%2F11%2Fapp-shell">英]</a></li></ul><h3 id="3-2-运行时性能">3.2. 运行时性能</h3><ul><li>[避免大型、复杂的布局和布局抖动 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Frendering%2Favoid-large-complex-layouts-and-layout-thrashing%3Fhl%3Dzh-cn%23avoid-forced-synchronous-layouts">英]</a></li><li>[什么导致强制同步布局（reflow）？ <a href="https://link.juejin.cn?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a">英]</a></li><li>[如何诊断强制同步布局 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fchrome-devtools%2Frendering-tools%2Fforced-synchronous-layouts%3Fhl%3Dzh-cn">英]</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Ftaobaofed.org%2Fblog%2F2016%2F04%2F25%2Fperformance-composite%2F">无线性能优化：Composite</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F30078937">如何不择手段提升scroll事件的性能</a></li><li>[使用 passive event listener 来提高滚动流畅性 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWICG%2FEventListenerOptions%2Fblob%2Fgh-pages%2Fexplainer.md">英]</a></li><li>节流和去抖（throttle &amp; debounce）：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhanzichi%2Funderscore-analysis%2Fissues%2F20">JavaScript 函数节流和函数去抖应用场景辨析</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhanzichi%2Funderscore-analysis%2Fissues%2F21">underscore 函数去抖的实现</a></li></ul></li><li>requestIdleCallback - 一个强大而神器的 API：<ul><li>[requestIdleCallback使用入门 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2015%2F08%2Fusing-requestidlecallback">英]</a></li><li>[Idle Until Urgent <a href="https://link.juejin.cn?target=https%3A%2F%2Fphilipwalton.com%2Farticles%2Fidle-until-urgent">英]</a>：requestIdleCallback的妙用</li></ul></li></ul><h3 id="3-3-前端缓存">3.3. 前端缓存</h3><ul><li>[Web 缓存简介：以购买牛奶的为例 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdev.to%2Fkbk0125%2Fweb-caching-explained-by-buying-milk-at-the-supermarket-9k4">英]</a></li><li>[大话前端缓存 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcalendar.perfplanet.com%2F2016%2Fa-tale-of-four-caches%2F">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Famandakelake%2Fblog%2Fissues%2F43">缓存（一）—— 缓存总览：从性能优化的角度看缓存</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Famandakelake%2Fblog%2Fissues%2F41">缓存（二）—— 浏览器缓存机制：强缓存、协商缓存</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Famandakelake%2Fblog%2Fissues%2F13">缓存（三）—— 数据存储：cookie、Storage、indexedDB</a></li></ul><h3 id="3-4-性能调试与实践">3.4. 性能调试与实践</h3><ul><li>[使用 Chrome DevTools 提升页面速度 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fchrome-devtools%2Fspeed%2Fget-started">英]</a>：Chrome DevTools实操讲解</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fchrome-devtools%2Fnetwork-performance%2Funderstanding-resource-timing">了解 DevTools 中的 Resource Timing</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000014359615">淘宝新势力周H5性能优化实战</a></li><li><a href="https://juejin.cn/post/6844903602134188046">优化打包策略来提升页面加载速度</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F42059158">Chrome DevTools 中你可能不知道的调试技巧</a></li><li>[前端性能测量 <a href="https://link.juejin.cn?target=https%3A%2F%2Fspeedcurve.com%2Fblog%2Fuser-timing-and-custom-metrics%2F">英]</a></li></ul><h3 id="3-5-性能指标">3.5. 性能指标</h3><ul><li>[以用户为中心的前端性能指标 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fuser-centric-performance-metrics">英]</a>：前端性能指标的来龙去脉</li><li>DOMContentLoaded:<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F25876048">你不知道的 DOMContentLoaded</a></li><li>[Deciphering the Critical Rendering Path <a href="https://link.juejin.cn?target=https%3A%2F%2Fcalendar.perfplanet.com%2F2012%2Fdeciphering-the-critical-rendering-path%2F">英]</a></li></ul></li><li>FP (First Paint)：<ul><li><a href="https://link.juejin.cn?target=http%3A%2F%2Feux.baidu.com%2Fblog%2Ffe%2FChrome%E7%9A%84First%20Paint">Chrome的First Paint</a></li></ul></li><li>FCP (First Contentful Paint)：<ul><li>[First Contentful Paint Explained <a href="https://link.juejin.cn?target=https%3A%2F%2Fgtmetrix.com%2Fblog%2Ffirst-contentful-paint-explained%2F">英]</a></li><li>[First Contentful Paint <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Flighthouse%2Faudits%2Ffirst-contentful-paint">英]</a></li></ul></li><li>FMP (First Meaningful Paint)：<ul><li><a href="https://juejin.cn/post/6844903489466793998">Chrome 中的 First Meaningful Paint</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI%2Fview%3Fhl%3Dzh-cn%23heading%3Dh.k50nnyhtptq0">Time to First Meaningful Paint</a></li></ul></li><li>TTI (Time to interactive)：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWICG%2Ftime-to-interactive">Time to Interactive Explainer</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcalendar.perfplanet.com%2F2017%2Ftime-to-interactive-measuring-more-of-the-user-experience%2F">衡量用户体验的新标准</a></li></ul></li><li>TTFB (Time To First Byte)：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23588780">TTFB，以及页面加载的时间节点</a></li></ul></li><li>FID (First Input Delay)：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F05%2Ffirst-input-delay">First Input Delay</a></li></ul></li><li>Speed Index：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsites.google.com%2Fa%2Fwebpagetest.org%2Fdocs%2Fusing-webpagetest%2Fmetrics%2Fspeed-index">WebPagetest: Speed Index</a></li></ul></li></ul><h2 id="4-安全">4. 安全</h2><blockquote><p>很多安全风险老生常谈，但是往往到出现问题时，才会被重视或者意识到。</p></blockquote><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Finsights.thoughtworks.cn%2Feight-security-problems-in-front-end%2F">8大前端安全问题上篇</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Finsights.thoughtworks.cn%2Feight-security-problems-in-front-end-2%2F">8大前端安全问题下篇</a></li><li>[概念讲解：编码、加密、哈希与混淆 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdanielmiessler.com%2Fstudy%2Fencoding-encryption-hashing-obfuscation">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzoumiaojiang.com%2Farticle%2Fcommon-web-security%2F">常见 Web 安全攻防总结</a></li></ul><h3 id="4-1-XSS">4.1. XSS</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2Ffe_security.html">如何防止XSS攻击？</a></li></ul><h3 id="4-2-CSRF">4.2. CSRF</h3><ul><li><a href="https://juejin.cn/post/6844903689702866952">如何防止CSRF攻击？</a></li><li>[Site Isolation <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F07%2Fsite-isolation">英]</a>：Chrome的新特性</li></ul><h3 id="4-3-CSP">4.3. CSP</h3><ul><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F09%2Fcsp.html">Content Security Policy 入门教程</a></li><li>[Content Security Policy (CSP) <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTTP%2FCSP">英]</a></li></ul><h3 id="4-4-HTTPS">4.4. HTTPS</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3NKOCOeIUF2SGJnY7II9hA">图文还原 HTTPS 原理</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013635363">浅谈有赞全站 HTTPS 推进</a></li></ul><h3 id="4-5-安全实录">4.5. 安全实录</h3><ul><li>[About <code>rel=noopener</code> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmathiasbynens.github.io%2Frel-noopener%2F">英]</a>：打开一个新页面是如何带来安全隐患的</li><li>[一种新型的“钓鱼”方式 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.azarask.in%2Fblog%2Fpost%2Fa-new-type-of-phishing-attack%2F">英]</a></li><li>[一个媒体文件请求引发的跨站风险 <a href="https://link.juejin.cn?target=https%3A%2F%2Fjakearchibald.com%2F2018%2Fi-discovered-a-browser-bug">英]</a></li><li>[Mitigating Spectre <a href="https://link.juejin.cn?target=https%3A%2F%2Fsecurity.googleblog.com%2F2018%2F07%2Fmitigating-spectre-with-site-isolation.html">英]</a>： Chrome 中的跨站安全问题</li></ul><h2 id="5-自动化测试">5. 自动化测试</h2><blockquote><p>自动化测试是软件工程的重要部分之一，但却极容易被忽视。</p></blockquote><ul><li>[2018 前端自动化测试综述 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fwelldone-software%2Fan-overview-of-javascript-testing-in-2018-f68950900bc3">英]</a></li><li>[测试你的前端代码（介绍篇）<a href="https://link.juejin.cn?target=https%3A%2F%2Fhackernoon.com%2Ftesting-your-frontend-code-part-i-introduction-7e307eac4446">英]</a></li></ul><h3 id="5-1-单元测试">5.1. 单元测试</h3><ul><li>[测试你的前端代码（单元测试篇）<a href="https://link.juejin.cn?target=https%3A%2F%2Fhackernoon.com%2Ftesting-your-frontend-code-part-ii-unit-testing-1d05f8d50859">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F26942686">Fakes、Mocks 以及 Stubs 概念明晰</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Ftest-coverage-rate-role">测试覆盖（率）到底有什么用？</a></li></ul><h3 id="5-2-端到端测试-E2E">5.2. 端到端测试 (E2E)</h3><ul><li>[测试你的前端代码（E2E 测试篇）<a href="https://link.juejin.cn?target=https%3A%2F%2Fhackernoon.com%2Ftesting-your-frontend-code-part-iii-e2e-testing-e9261b56475">英]</a></li><li>[什么是一个好的 E2E 测试？<a href="https://link.juejin.cn?target=https%3A%2F%2Ftesting.googleblog.com%2F2016%2F09%2Ftesting-on-toilet-what-makes-good-end.html">英]</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fbalancing-unit-and-end-to-end-tests">平衡单元测试和端到端测试</a></li><li>[对过多的 E2E 测试说“不” <a href="https://link.juejin.cn?target=https%3A%2F%2Ftesting.googleblog.com%2F2015%2F04%2Fjust-say-no-to-more-end-to-end-tests.html">英]</a></li></ul><h3 id="5-3-其他">5.3. 其他</h3><ul><li>[测试你的前端代码（集成测试篇）<a href="https://link.juejin.cn?target=https%3A%2F%2Fhackernoon.com%2Ftesting-your-frontend-code-part-iv-integration-testing-f1f4609dc4d9">英]</a></li><li>[测试你的前端代码（可视化测试篇）<a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40giltayar%2Ftesting-your-frontend-code-part-v-visual-testing-935864cfb5c7">英]</a></li></ul><h2 id="6-框架与类库">6. 框架与类库</h2><blockquote><p>如果说基础知识是道，那框架与工具可能就是术；学习与理解它们，但千万不要成为它们的奴隶。</p></blockquote><h3 id="6-1-React">6.1. React</h3><ul><li>[React 底层揭秘 <a href="https://link.juejin.cn?target=https%3A%2F%2Fbogdan-lyashenko.github.io%2FUnder-the-hood-ReactJS%2F">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhateonion%2Freact-bits-CN">你所需要知道的 React 细节</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F37095662">React Fiber 架构</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fzxc0328.github.io%2F2017%2F09%2F28%2Freact-16-source%2F">React 16 Fiber 源码速览</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013365426">React 是怎样炼成的</a>：React早期的进化之路</li><li>从零开始实现一个React：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhujiulong%2Fblog%2Fissues%2F4">1. JSX和虚拟DOM</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhujiulong%2Fblog%2Fissues%2F5">2. 组件和生命周期</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhujiulong%2Fblog%2Fissues%2F6">3. diff算法</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhujiulong%2Fblog%2Fissues%2F7">4. 异步的setState</a></li></ul></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F0b2acb50f321">「react技术栈」单页应用实践快速入门</a></li></ul><h3 id="6-2-Vue">6.2. Vue</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fberwin%2FBlog%2Fissues%2F17">深入浅出 - vue变化侦测原理</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fberwin%2FBlog%2Fissues%2F18">Vue 模板编译原理</a></li></ul><h3 id="6-3-Redux">6.3. Redux</h3><ul><li>[重新设计 Redux <a href="https://link.juejin.cn?target=https%3A%2F%2Fhackernoon.com%2Fredesigning-redux-b2baee8b8a38">英]</a>：Rematch</li><li>[如何用 GraphQL 来替代 Redux <a href="https://link.juejin.cn?target=https%3A%2F%2Fhackernoon.com%2Fhow-graphql-replaces-redux-3fff8289221d">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdiv.io%2Ftopic%2F1309">解读 Redux 的设计思路与用法</a></li><li>[(Redux)应用构建的三个原则 <a href="https://link.juejin.cn?target=https%3A%2F%2Fjaysoo.ca%2F2016%2F02%2F28%2Forganizing-redux-application%2F%23rule-1-organize-by-feature">英]</a></li></ul><h3 id="6-4-RxJS">6.4. RxJS</h3><ul><li><a href="https://link.juejin.cn?target=http%3A%2F%2Freactivex.io%2F">ReactiveX 官网</a>：宝石图真的非常形象易读</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fandroid-blogs%2Fp%2F5586395.html">响应式编程，是明智的选择</a></li><li>[图解RxJS <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.angularindepth.com%2Flearn-to-combine-rxjs-sequences-with-super-intuitive-interactive-diagrams-20fce8e6511">英]</a></li><li>[调试RxJS：Tooling <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.angularindepth.com%2Fdebugging-rxjs-4f0340286dd3">英]</a></li><li>[调试RxJS：Logging <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.angularindepth.com%2Fdebugging-rxjs-part-2-logging-56904459f144">英]</a></li></ul><h2 id="7-新技术-方向">7. 新技术/方向</h2><blockquote><p>前端领域新技术、新方向层出不穷，这里汇总一些新技术方向；作为开发者需要多了解但是不要盲从</p></blockquote><h3 id="7-1-PWA">7.1. PWA</h3><ul><li><a href="https://juejin.cn/post/6844903588267835406#heading-3">PWA 学习与实践系列</a></li><li>[Service Worker 入门简介 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.freecodecamp.org%2Fservice-workers-the-little-heroes-behind-progressive-web-apps-431cc22d0f16">英]</a></li><li>[PWA 在 iOS 平台上的特殊问题 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40firt%2Fpwas-are-coming-to-ios-11-3-cupertino-we-have-a-problem-2ff49fd7d6ea">英]</a></li><li>[在你的 PWA 中小心使用 iOS 的 meta 标签 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40firt%2Fdont-use-ios-web-app-meta-tag-irresponsibly-in-your-progressive-web-apps-85d70f4438cb">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Felemefe%2Fupgrading-ele-me-to-progressive-web-app-2a446832e509">饿了么的 PWA 升级实践</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Finstant-and-offline%2Foffline-cookbook%2F">离线指南</a></li><li>[Android 中的 WebAPKs <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.cn%2Fweb%2Ffundamentals%2Fintegration%2Fwebapks%3Fhl%3Dzh-cn">英]</a></li><li>[Pinterest 的 PWA 实践 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40Pinterest_Engineering%2Fa-one-year-pwa-retrospective-f4a2f4129e05">英]</a></li><li>[异步 HTTP Cookies API <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Fasynchronous-access-to-http-cookies">英]</a>：赋能Service Worker</li></ul><h3 id="7-2-CSS-Houdini">7.2. CSS Houdini</h3><ul><li>[认识 Houdini 与 CSS Paint API <a href="https://link.juejin.cn?target=https%3A%2F%2Fcodersblock.com%2Fblog%2Fsay-hello-to-houdini-and-the-css-paint-api%2F">英]</a></li><li>[用 Houdini 来拯救 CSS Polyfill <a href="https://link.juejin.cn?target=https%3A%2F%2Fphilipwalton.com%2Farticles%2Fthe-dark-side-of-polyfilling-css%2F">英]</a></li></ul><h3 id="7-3-Web-Components">7.3. Web Components</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FWeb_Components">Web Components 基本概念和用法</a></li><li>[Web Components 指南 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fmodular-future-web-components%2F">英]</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fweb.jobbole.com%2F87088%2F">Shadow DOM 使用简介</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2018%2F03%2Fhtmlunknownelement-html5-custom-elements%2F">HTMLUnknownElement 与 HTML5 自定义元素的故事</a></li></ul><h3 id="7-4-微前端（Micro-Frontends）">7.4. 微前端（Micro Frontends）</h3><ul><li>[微前端主页 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmicro-frontends.org%2F">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmicrofrontend.cn%2F">微前端的那些事儿</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F32378432">技术雷达之「微前端」- 将微服务理念扩展到前端开发</a></li></ul><h3 id="7-5-HTTP-2">7.5. HTTP/2</h3><ul><li><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-http2-under-the-hood%2Findex.html">HTTP/2 幕后原理</a></p></li><li><p>[全面介绍的 HTTP/2 <a href="https://link.juejin.cn?target=https%3A%2F%2Fhpbn.co%2Fhttp2%2F">英]</a></p></li><li><p>HTTP/2 主页</p><p>:</p><ul><li>[HTTP/2 协议 <a href="https://link.juejin.cn?target=https%3A%2F%2Fhttpwg.org%2Fspecs%2Frfc7540.html">英]</a></li><li>[HPACK: HTTP/2 Header压缩 <a href="https://link.juejin.cn?target=https%3A%2F%2Fhttpwg.org%2Fspecs%2Frfc7541.html">英]</a></li></ul></li></ul><h3 id="7-6-WebAssembly">7.6. WebAssembly</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebassembly.org%2F">WebAssembly 官网</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-lo-webassembly-status-and-reality%2Findex.html">WebAssembly 现状与实战</a></li><li>WebAssembly 系列：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008714589">一、生动形象地介绍 WebAssembly</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008632441">二、JavaScript Just-in-time (JIT) 工作原理</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008664761">三、编译器如何生成汇编</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008686643">四、WebAssembly 工作原理</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008699213">五、为什么 WebAssembly 更快？</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008714515">六、WebAssembly 的现在与未来</a></li></ul></li></ul><h2 id="8-业务相关">8. 业务相关</h2><blockquote><p>在业务中往往还有一些与“业务无关”的场景需求，不论是什么业务几乎都会遇到；因此，在变与不变中，我们更需要去抽象出这些问题。</p></blockquote><h3 id="8-1-数据打点上报">8.1. 数据打点上报</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftechblog.toutiao.com%2F2018%2F06%2F05%2Fru-he-jing-que-tong-ji-ye-mian-ting-liu-shi-chang%2F">如何精确统计页面停留时长</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Funclechen.github.io%2F2018%2F06%2F24%2F%E6%8F%AD%E5%BC%80JS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%2F">揭开JS无埋点技术的神秘面纱</a></li></ul><h3 id="8-2-前端监控">8.2. 前端监控</h3><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcdc.tencent.com%2F2018%2F09%2F13%2Ffrontend-exception-monitor-research%2F">前端异常监控解决方案研究</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2Fhunt_sdk_practice.html">监控平台前端SDK开发实践</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F32262716">把前端监控做到极致</a></li><li><a href="https://juejin.cn/post/6844903541862039566">前端监控系统探索总结</a></li></ul><h3 id="8-3-A-B测试">8.3. A/B测试</h3><ul><li>Twitter的A/B测试实践：<ul><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Ftwitter-ab-test-practise-part01">一、为什么要测试以及测试的意义</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Ftwitter-ab-test-practise-part02">二、技术概述</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Ftwitter-ab-test-practise-part03">三、检测和避免 A/B Test中 bucket不平衡问题</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Ftwitter-ab-test-practise-part04">四、A/B Test中使用多个控制的启示</a></li></ul></li><li>[Netflix A/B Test 实验平台实践 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fnetflix-techblog%2Fits-all-a-bout-testing-the-netflix-experimentation-platform-4e1ca458c15">英]</a></li><li>指导方法<ul><li>[实验中容易遇到的七种问题 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.exp-platform.com%2FDocuments%2F2009-ExPpitfalls.pdf">英]</a></li><li>[实验的七个准则 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.exp-platform.com%2FDocuments%2F2014%20experimentersRulesOfThumb.pdf">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F3ab537f16b81">小流量如何进行AB测试</a></li></ul></li><li>案例分享<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.csdn.net%2Farticle%2F2015-03-24%2F2824303">大众点评AB测试框架Gemini</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000012377139">新浪新闻客户端AB测试与灰度发布</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Ftmall-app-ab-test">天猫App A/B测试实践</a></li></ul></li><li>工具<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.eyeofcloud.com%2F124.html">AB测试样本数量计算器</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.eyeofcloud.com%2F126.html">AB测试结果有效性分析工具</a></li></ul></li></ul><h3 id="8-4-“服务端推”">8.4. “服务端推”</h3><ul><li><a href="https://juejin.cn/post/6844903618043183111">各类“服务器推”技术原理与实例</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F31297574">长连接/websocket/SSE等主流服务器推送技术比较</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-lo-comet%2F">Comet：基于 HTTP 长连接的“服务器推”技术</a></li><li>[深入 WebSockets、HTTP/2 SSE <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7">英]</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsecurity.tencent.com%2Findex.php%2Fblog%2Fmsg%2F119">WebSocket 应用安全问题分析</a></li></ul><h3 id="8-5-动效">8.5. 动效</h3><ul><li>[动画设计的12个原则🎥 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DuDqjIdI4bF4">英]</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.html-js.com%2Farticle%2F1628">贝塞尔曲线扫盲</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Faotu.io%2Fnotes%2F2018%2F03%2F06%2Fae2web%2F">动画：从 AE 到 Web</a></li><li>最全最好用的动效落地方法：<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34501702">基础知识</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34815524">落地方式</a></li></ul></li></ul><h2 id="9-不归类的好文">9. 不归类的好文</h2><blockquote><p>开卷有益。</p></blockquote><ul><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fraganwald.com%2F2018%2F05%2F20%2Fwe-dont-need-no-stinking-recursion.html">Recursion? We don’t need no stinking recursion!</a>：如何将一些递归改为循环（尾递归优化）</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fben.akrin.com%2F%3Fp%3D5997">Turning your web traffic into a Super Computer</a>：通过 Web Worker 和 WebSocket 来将全世界的电脑连接成超级计算机</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40cramforce%2Fdesigning-very-large-javascript-applications-6e013a3291a3">Designing very large (JavaScript) applications</a>：高屋建瓴，适合阅读与思考</li></ul><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaScript&quot;&gt;JavaScript&lt;/h2&gt;
&lt;h4 id=&quot;原生-js-系列&quot;&gt;原生 js 系列&lt;/h4&gt;
&lt;p&gt;冴羽大佬的这篇博客里，除了 undescore 的部分，你需要全部都能掌握。并且灵活的运用到开发中去。&lt;br&gt;
&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>eventloop</title>
    <link href="http://example.com/2021/11/02/eventloop/"/>
    <id>http://example.com/2021/11/02/eventloop/</id>
    <published>2021-11-02T02:49:32.000Z</published>
    <updated>2021-11-02T08:01:16.090Z</updated>
    
    <content type="html"><![CDATA[<p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">console.log('script start');setTimeout(function () &#123;  console.log('setTimeout');&#125;, 0);Promise.resolve()  .then(function () &#123;    console.log('promise1');  &#125;)  .then(function () &#123;    console.log('promise2');  &#125;);console.log('script end'); //script start, script end, promise1, promise2, setTimeout</code></pre><p>需要理解 event loop 如何处理 tasks 和 microtasks.</p><p>每个 ‘thread’ 有自己的 <strong>event loop</strong>, 所以每个web工作者有自己的envent loop, 所以它可以独立执行，然而同源的所有窗口共享同一个event loop并且它们可以同步通信. event loop是连续运行的,执行一些任务队列. 一个 event loop 有不同的 task sources保证执行顺序在 within that source (specs <a href="https://w3c.github.io/IndexedDB/#database-access-task-source">such as IndexedDB</a> define their own), but the browser gets to pick which source to take a task from on each turn of the loop. This allows the browser to give preference to performance sensitive tasks such as user-input. Ok ok, stay with me…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p class=&quot;code-caption&quot; data-lang=&quot;js&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;</summary>
      
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/11/02/eventloop%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>http://example.com/2021/11/02/eventloop%E7%9A%84%E5%89%AF%E6%9C%AC/</id>
    <published>2021-11-02T02:49:32.000Z</published>
    <updated>2021-11-02T07:52:06.195Z</updated>
    
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    
    <category term="mac" scheme="http://example.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>便捷工具</title>
    <link href="http://example.com/2021/11/02/%E4%BE%BF%E6%8D%B7%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2021/11/02/%E4%BE%BF%E6%8D%B7%E5%B7%A5%E5%85%B7/</id>
    <published>2021-11-02T02:49:32.000Z</published>
    <updated>2021-11-05T07:51:08.083Z</updated>
    
    <content type="html"><![CDATA[<h1>截图工具</h1><ol><li><h2 id="Snipaste">Snipaste</h2></li></ol><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=YzlkMmRkZjVmMjIwMjNiNjc1NzcwOTRjNzg1YmU2M2FfUk9Qc3g0WVZxTXFvTFJIQUFWZjZTVnJJUUVMYUVSZnRfVG9rZW46Ym94Y25teFgwclNUSW82TG5yRjlucktjeW5iXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p><a href="https://zh.snipaste.com/download.html">下载链接</a></p><p><strong>下载安装包</strong>后，双击拖动到程序坞里。双击一下任务栏里Snipaste的图标，就会在后台运行了。</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTkyNzFkYTJjY2JiZDNiMmNiYTFhMGU2MWVkZjhjNTNfY2gwYzVUTFBDTTlJd0NOZmJBTEtHOTR5eDJsdEhhdFpfVG9rZW46Ym94Y25mc2NqOE5YY1RUcG0zZXQyWWRzRVZmXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p><strong>功能：截图、贴图、取色</strong></p><p><strong>截图：快捷键Fn + F1</strong> ，可以自动、捕抓各个界面、图标、文字，无需自己调整，也可以自由选择。</p><p><strong>编辑：截图之后编辑图片</strong>。有线条、画框、箭头、画笔、记号笔，文字(可选字体)，可选颜色。马赛克(笔触大小、样式可选)</p><p><strong>贴图：快捷键Fn+F3，<strong>截图可以钉在屏幕最前面，可以</strong>随意移动、放大缩小</strong>。</p><p>​    并且可以自己创建分组进行管理。</p><p>​    <strong>快捷键esc退出</strong>（mac这个键好像没用）需要在图片上右键选择关闭</p><p>取色器：<strong>快捷键Fn + F1</strong> ，将光标放在想要取的颜色上，按<strong>C</strong>键即可提取。</p><p>​        <strong>快捷键Fn + F3</strong> ，所取<strong>颜色的参数</strong>就会置顶在屏幕上。</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2M0NjBhZmEyNzVjOTMxMGU3YmVhNDVjMjY5MTE3MDFfdU5mMEdIVUZFd1ZOcnlkUHFHMkJWc21QeDh6YjA1YzlfVG9rZW46Ym94Y255SWQyZEpLUWxDaDF0eThpSXNYbjRnXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><ol><li><h2 id="FastStone-Capture">FastStone Capture</h2></li></ol><p>只能在windows系统上使用</p><p><a href="https://www.faststonecapture.cn/">https://www.faststonecapture.cn/</a></p><h3 id="功能介绍">功能介绍</h3><p>1.主界面</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=NzE2OGMwZDk0MDQwZmM2Mzk0MjM2YzU2NzcxZjU3Y2NfN1liblRadE9zbWVFdWt1SjJpWllBTzFJd1hzVHZyeGxfVG9rZW46Ym94Y25XTnlqTDRxZXptYmVDMWhOdlNyNVJnXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>2.截图编辑界面</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDcwMjJjYjYxMTQ3MTE4ZmRhMTM2NTNmYzdjOWEwOTBfNEtJOUFyWllSUWJoWDJnbFJ6MWhGRUdKNWRoVFJJY0JfVG9rZW46Ym94Y25RUE1GdzUyMVNjM010d2dUa2dyQ1RmXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>3.图片裁剪、剪切、复制</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFmNmI5M2RkZDMxNmE0MTEzMzFkZTZkMTcyMDQxNGRfeGZGYUFuQkp6U3BxMzJuR2o5Y21VeHcxZVNPdzFxOXdfVG9rZW46Ym94Y25tcDVuOGFxQXo0YlFlNTRJTFBxTktlXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>4.图片添加标题功能</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=NmY2MDdhMDkxNTdhMjliMWEwYmExNDgwY2U1ZDY4OWJfN2xjZ0ZKaENoeDQ4Q3NoUWs2bVYxVGJQQ09FVnJLbVlfVG9rZW46Ym94Y241M3dmWUdpZkZCd3BaOHQyUUJZV21lXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>5.抠图功能：自带各个形状工具，进行捕捉抓取</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJiOWQ0NGZiMGU2YzZkZjFmZjg4ODkzYTcwNDU1NmJfWjM2V3JVdmo3YnF6cWY2U3FLRnRIYXNFYk1hdGYxZzdfVG9rZW46Ym94Y25nRml0clVKc29sYkhjYk04OHZMZ0hnXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>6.截图放大、缩小功能，显示比例设置</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJmMDZjNjhiOWUzZDMxMDE0YTYzMDQ0NGFjOGI2MTVfdk1hVWgwR3FCeDJPcTA4VlVqOG5ONldJRWphRHh4Y09fVG9rZW46Ym94Y25lRUsyZFFzUWJIYWw5bTJkZzliMFZnXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>7.画图功能</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ODdmY2U2ZDU2ZTBhNTRjNzc3YzQ4YzhmMTQ0OWZkNmVfUlhnTVJ0NnI5dGljSFJJYm84dnJ4WnJzY2dSWEFKcEhfVG9rZW46Ym94Y24wVXpuQ0s4TnN6T0pLMnVwY2ZIUzVvXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>8.图片大小设置</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM1YWZmMTRjOTI5OWEzZGEyYTljMjdjZjM3ZjAyN2Vfa1VRN3F2a1VFZmowUDJ3MzByS3A2RWRudXdWS3B6N01fVG9rZW46Ym94Y24yNmVqYWxsc3FyYUpjRU11b3dwWkZjXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p>9.自定义绘图功能</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI4YjBlNmRhNTJlYjkwZmIzYmFhNzUyYWQzNTgxZjhfNHB3N3FJQ2VqSExQYlNDbXlsaWw3UldzQUxLTWJ3WmdfVG9rZW46Ym94Y24zSXRVVnFUOWNVcnJZSUVwcllNRVhiXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=OWYxOTJkOTY5YTRhODM5YWM4ODYxZTQ2YjM3MWE2OGJfZGhSaUVZWTJvMEF5NGNSc3pwekJTcUFsTndWbGNJSm5fVG9rZW46Ym94Y25WOTlzaFV3NUgyb29yM05JMVNWTGZkXzE2MzU4MjE0ODM6MTYzNTgyNTA4M19WNA" alt="img"></p><h1>视频播放器</h1><p><a href="https://zhuanlan.zhihu.com/p/24700324">IINA -  一个现代的 macOS 视频播放器</a></p><h2 id="vscode-修改文件后保存-会生成dist文件">vscode 修改文件后保存 会生成dist文件</h2><p>问题：修改文件后会生成dist文件</p><p>解决： 禁用该插件</p><p>![image-20211105155107365](/Users/bytedance/Library/Application Support/typora-user-images/image-20211105155107365.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;截图工具&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h2 id=&quot;Snipaste&quot;&gt;Snipaste&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bytedance.feishu.cn/space/api/box/stream/download/a</summary>
      
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    
    <category term="mac" scheme="http://example.com/tags/mac/"/>
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>fs图片上传</title>
    <link href="http://example.com/2021/11/02/node%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://example.com/2021/11/02/node%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2021-11-02T02:49:32.000Z</published>
    <updated>2021-11-05T06:29:15.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fs-unlink-一直显示路径不存在问题">fs.unlink 一直显示路径不存在问题</h2><p>问题描述：由于用户头像支持修改上传，所以需要把前一张图片删除掉，就要查询用户图片名并分割拼接成文件地址，一开始用的是 ‘public/images’+文件名拼接成的字符串，一直显示找不到路径，以为是以当前项目路径为根路径的，实际是从用户根路径直接一路定位</p><p>解决：使用path拼接路径，先取得当前绝对路径,再定位到目标文件夹下并拼接上文件名</p><p>path.join(__dirname,‘…/public/images’, filename)</p><h2 id="关于图片从库中已经删除无法去重的问题">关于图片从库中已经删除无法去重的问题</h2><h3 id="使用-fs-access检查文件是否存在"><strong>使用 fs.access检查文件是否存在</strong></h3><p>fs.access 接收一个 mode 参数可以判断一个文件是否存在、是否可读、是否可写，返回值为一个 err 参数。</p><h2 id="path函数">path函数</h2><h3 id="path-join-paths"><code>path.join([...paths])</code></h3><ul><li><p><code>...paths</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a> A sequence of path segments</p></li><li><p>Returns <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a></p></li></ul><p><code>path.join()</code>把所有的<code>path</code> 片段(必须是string类型)使用特定于平台的分隔符作为分隔符(这里不论你使用的分割符是否正确都可以得到正确的路径) ,最后序列化路径</p><p>0长<code>path</code> 片段会被忽略.  <code>'.'</code>代表当前工作路径，'…'代表上一级工作路径</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// Returns: '/foo/bar/baz/asdf'path.join('foo', &#123;&#125;, 'bar');// Throws 'TypeError: Path must be a string. Received &#123;&#125;'</code></pre><h3 id="path-parse-path"><code>path.parse(path)</code></h3><ul><li><p><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a></p></li><li><p>Returns <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"></a></p></li></ul><p><code>path.parse()返回包含路径属性的path</code>.</p><ul><li><p><code>dir</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a></p></li><li><p><code>root</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a></p></li><li><p><code>base</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a></p></li><li><p><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a></p></li><li><p><code>ext</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type"></a></p></li></ul><p>For example, on POSIX:</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">path.parse('/home/user/dir/file.txt');// Returns:// &#123; root: '/',//   dir: '/home/user/dir',//   base: 'file.txt',//   ext: '.txt',//   name: 'file' &#125;</code></pre><p>On Windows:</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">path.parse('C:\\path\\dir\\file.txt');// Returns:// &#123; root: 'C:\\',//   dir: 'C:\\path\\dir',//   base: 'file.txt',//   ext: '.txt',//   name: 'file' &#125;</code></pre><h2 id="图片一次上传之后就无法继续上传">图片一次上传之后就无法继续上传</h2><p>使用el-uploade的时候因为要限制图片只能上传一张，所以额外定义了上传文件列表，但上传成功后没有清空</p><p class="code-caption" data-lang="vue" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-vue">&lt;el-upload  class=&quot;up_portrait_box&quot;  action=&quot;/user/upload&quot;  :file-list=&quot;fileList&quot;  :show-file-list=&quot;false&quot;  :on-success=&quot;handleSucess&quot;  :on-exceed=&quot;handleExceed&quot;  :before-upload=&quot;beforeAvatarUpload&quot;  :limit=&quot;1&quot;  accept=&quot;.jpg, .jpeg, .png&quot;&gt;  &lt;!-- &lt;el-tooltip    content=&quot;上传头像，500kb以内的image/jpeg/jpg/png文件&quot;    placement=&quot;right&quot;  &gt;&lt;/el-tooltip  &gt; --&gt;  &lt;div class=&quot;up_portrait_mask&quot;&gt;    &lt;i class=&quot;el-icon-camera&quot;&gt;&lt;/i&gt;  &lt;/div&gt;  &lt;Avatar    :size=&quot;60&quot;    :url=&quot;friendinfo.portrait&quot;    :text=&quot;friendinfo.username&quot;    style=&quot;margin-right: 40px&quot;  /&gt;&lt;/el-upload&gt;</code></pre><pre><code class="language-js">// 文件超出限制时处理的函数    handleExceed(files, fileList) &#123;      // 当上传文件数最大设置为1,再次选择新文件时会触发这个方法，利用这个对文件进行重新赋值即可      // files为当前选择的文件，fileList已经选择后的文件（上次选择的）      // 可以对fileList进行赋值来修改上传时的文件。但是只修改fileList是不够的，      // 还需要修改el-upload里的uploadFiles，保持数据同步，不然上传后的回调函数里的字段会报错。这里就是自定义的this.fileslist      // 多选时选最后一个文件      this.fileList = files[files.length - 1]    &#125;,    // 限制上传头像文件的大小和类型    beforeAvatarUpload(file) &#123;      const isJPG =        file.type === 'image/jpeg' ||        file.type === 'image/png' ||        file.type === 'image/jpg'      const isLt2M = file.size / 1024 / 1024 &lt; 1      if (!isJPG) &#123;        this.$message.error('上传头像图片只能是 JPG/JPEG/PNG 格式!')      &#125;      if (!isLt2M) &#123;        this.$message.error('上传头像图片大小不能超过 1MB!')      &#125;      return isJPG &amp;&amp; isLt2M    &#125;,    // 上传文件    handleSucess(response, file, fileList) &#123;      if (response.errno === 0) &#123;        this.$message.success('图像修改成功')        this.friendinfo.portrait = response.message        // 清空文件列表,准备下次上传        this.fileList = []      &#125;    &#125;&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;</code></pre><h2 id="图片不存在时使用用户名做头像">图片不存在时使用用户名做头像</h2><pre><code class="language-vue"> &lt;el-avatar v-bgc=&quot;(text, this)&quot; :size=&quot;size&quot;  class=&quot;avatar&quot; :key=&quot;url&quot; :src=&quot;url&quot; ref=&quot;image&quot;  :onerror=&quot;imgLoadError()&quot;&gt;  &#123;&#123; username | cutName &#125;&#125;&lt;/el-avatar&gt;</code></pre><pre><code class="language-js">// 自定义命令，用于随机生成背景颜色directives: &#123;    bgc: &#123;      // 使用时给标签添加v-bgc就可以了      //自定义命令里是获取不到this值的因此需要外部传递，还可以传递数值      //通过 binding.value.参数名 获取      inserted(el, binding) &#123;        // 配色方案，可自行修改，这里每次颜色不固定，观感较差        // 准备利用用户名首字符映射的方式，这样防止颜色更改        // 获取名字第一个文字，转换成16进制颜色值        const firstName = binding.value.text.substring(1, 0)        console.log(firstName)        // tranColor = (name) =&gt; &#123;        //  var str ='';        //  for(var i=0; i&lt;name.length; i++) &#123;        //   str += parseInt(name[i].charCodeAt(0), 10).toString(16);        //  &#125;        //  return '#' + str.slice(1, 4);        // &#125;        // const bgColor = this.tranColor(name)        // 这样就可以生成一个合法的16进制颜色字符串，如果需要配置不同的透明度，可以多取一位 str.slice(1, 5)，因为这里转换为16进制，所以这里只取前3位（1 ～ 4）        const colorArray = [          '63B4B8',          'CE97B0',          '19B3B1',          'A7BBC7',          '7952B3',          '5580A0',          'E5BB4B',          'CC8A56',          'A6C2CE',          'BFA2DB',          'B5525C'        ]        const a = () =&gt; Math.floor(Math.random(firstName) * colorArray.length)        const rand = a()        el.style.background = '#fff'        el.style.border = '1px solid #' + colorArray[rand]        el.style.color = '#' + colorArray[rand]        // el.style.background = `rgb($&#123;a()&#125;,$&#123;a()&#125;,$&#123;a()&#125;)`      &#125;    &#125;  &#125;,  methods: &#123;    //  头像加载失败就用用户名代替    async imgLoadError() &#123;      // 注意，setTimeout()如果用到 this ，必须在函数外定义一个变量来暂存 this 。      const that = this      // 刚开始用户信息没取到，有可能是网络加载慢延时一会      setTimeout(function () &#123;        that.avaurl = ''        that.username = that.text        console.log(that.username)      &#125;, 500) // 0.5秒    &#125;  &#125;,  filters: &#123;    cutName: function (value) &#123;      let res = value      if (value.length &lt;= 2) &#123;        return res      &#125;      if (value.length === 4) &#123;        res = value.slice(2, -1)      &#125; else &#123;        res = value.slice(-2)      &#125;      return res    &#125;  &#125;&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;</code></pre><h3 id="charCodeAt-fromCharCode">charCodeAt\fromCharCode</h3><p>charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。</p><pre><code class="language-js">'abc'.charCodeAt(1) // 98   abc的1号位置的字符是b，它的 Unicode 码点是98。</code></pre><p>String.fromCharCode()<br>String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">String.fromCharCode() // “”String.fromCharCode(97) // “a”String.fromCharCode(104, 101, 108, 108, 111) // “hello”</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;fs-unlink-一直显示路径不存在问题&quot;&gt;fs.unlink 一直显示路径不存在问题&lt;/h2&gt;
&lt;p&gt;问题描述：由于用户头像支持修改上传，所以需要把前一张图片删除掉，就要查询用户图片名并分割拼接成文件地址，一开始用的是 ‘public/images’+文件名拼</summary>
      
    
    
    
    <category term="imhere开发" scheme="http://example.com/categories/imhere%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="node" scheme="http://example.com/tags/node/"/>
    
    <category term="fs" scheme="http://example.com/tags/fs/"/>
    
  </entry>
  
  <entry>
    <title>hover图片显示遮罩</title>
    <link href="http://example.com/2021/11/02/%E5%9B%BE%E7%89%87%E9%81%AE%E7%BD%A9/"/>
    <id>http://example.com/2021/11/02/%E5%9B%BE%E7%89%87%E9%81%AE%E7%BD%A9/</id>
    <published>2021-11-02T02:49:32.000Z</published>
    <updated>2021-11-03T09:35:13.698Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/Asuna_Yu/article/details/80259194">https://blog.csdn.net/Asuna_Yu/article/details/80259194</a></p><p><strong>为图片及遮罩层添加样式</strong></p><p>图片：relative</p><p>遮罩层：absolute</p><p>使两者样式重合。</p><p>鼠标不在图片上时，遮罩层不显示 <code>.mask &#123; opacity: 0; &#125;</code> 。</p><p><strong>使用hover</strong></p><p>改变透明度，使遮罩层显示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/Asuna_Yu/article/details/80259194&quot;&gt;https://blog.csdn.net/Asuna_Yu/article/details/80259194&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Github 加 hexo 搭建自己的博客</title>
    <link href="http://example.com/2021/11/01/github%20hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2021/11/01/github%20hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-11-01T11:49:32.000Z</published>
    <updated>2021-11-02T02:34:29.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装">安装</h2><p>git：git 可以在我们的电脑上创建一个本地仓库，然后把我们的网页部署到 github 上的 github Pages 上。</p><p>node.js:安装 Hexo 的前提。</p><p>Hexo：可以把我们本地的 Markdown 文件，<a href="http://xn--fqr621h.md">后缀.md</a> 的文件，处理，渲染，然后变成静态网页，也就是我们的博客</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">npm config set registry https://registry.npm.taobao.org 设置国内的淘宝镜像，其他镜像也可以`npm config get registry  检查换成功没安装Hexonpm install hexo-cli -g安装hexo的一个相当于命令的东西npm install hexo-deployer-git --savecode snippet</code></pre><h2 id="搭建博客">搭建博客</h2><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">创建文件夹，并进去mkdir -p ~/codes/myblog &amp;&amp; cd ~/codes/mybloghexo init 初始化启动 访问localhost:4000 博客雏形就出来了hexo s         默认端口4000Hexo 命令npm update hexo -g #升级命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</code></pre><h2 id="github-配置">github 配置</h2><h3 id="配置-ssh-key">配置 ssh key</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">ssh-keygen -t rsa -C &quot;邮箱@example.com&quot;ssh-keygen -t rsa -C &quot;邮箱@example.com&quot; -f ~/.ssh/前缀id_rsa  防止和默认名重复ssh-add ~/.ssh/前缀_id_rsa       添加到信任列表pbcopy &lt; ~/.ssh/前缀_id_rsa.pub  复制公钥，粘贴到git网站的公钥中去open ~/.ssh/ 配置新账号，多git账号时使用添加下面的内容#个人2Host blogHostname gihub.comIdentityFile ~/.ssh/github_id_rsaUser blogssh -T git@blog 测试连接</code></pre><h3 id="创建仓库">创建仓库</h3><blockquote><p>注意：填写 Repository name，格式为 <a href="http://xxx.github.io">xxx.github.io</a>，xxx 就是你的用户名，xxx 必须和你的用户名匹配，一个账户只能在 Github 上创建一个 blog 仓库。</p></blockquote><p>![image-20211101184859389](/Users/bytedance/Library/Application Support/typora-user-images/image-20211101184859389.png)</p><h3 id="推送网站"><strong>推送网站</strong></h3><p>在 blog 根目录里的_config.yml 文件称为<strong>站点</strong>配置文件</p><p>根目录里的 themes 文件夹，里面也有个_config.yml 文件，这个称为<strong>主题</strong>配置文件</p><p>将 Hexo 与 GitHub 关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">deploy:type: gitrepo: git@github.com: ***/chenQD-blog.gitbranch: master</code></pre><p>记住这有个坑，</p><p>这里不要使用 https 链接，要不 hexo deploy 时重复输入用户名密码的问题</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">hexo cleanhexo ghexo d或者hexo generate -deploy  生成+部署</code></pre><p>如果报错：说明最开始安装的 deploy 没成功，会也有提示（会让你安装）： ERROR Deployer not found: git</p><p>只需要安装好即可</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">npm install hexo-deployer-git --save</code></pre><p>当配置完_config.yml 文件时，执行 hexo g -d 时出现错误如下：上面的配置文件格式缩进不正确，报错</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">FATAL YAMLException: bad indentation of a mapping entry (110:23) 107 | 108 | deploy: 109 |   type: git 110 |   repo: git@github.com: f-dAd/f-dAd.github.io.git-----------------------------^</code></pre><h2 id="博客样式">博客样式</h2><p>可以去 hexo 官网去挑选样式，下面几个是我很喜欢的样式</p><p><a href="https://github.com/Haojen/hexo-theme-Claudia">Claudia</a> ，<a href="https://github.com/nameoverflow/hexo-theme-icalm">icalm</a>，<a href="https://github.com/XPoet/hexo-theme-keep">Keep</a>，<a href="https://github.com/fi3ework/hexo-theme-archer">Archer</a></p><p>找到对应博客样式的 github 按教程安装</p><p>简单方式：直接 git clone 一份别人配置好的 themes 文件夹直接替换自己的文件夹并，在_config.yml 文件里把主题换成 themes 文件夹里对应的主题问件夹名</p><p>hexo generate -deploy 部署</p><h2 id="备份博客源文件">备份博客源文件</h2><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到 github 上面。</p><p>首先在 github 博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地一个新建的文件夹，把<code>.git</code>文件夹拿出来，放在博客根目录下。cmd + shift + . 显示隐藏文件夹</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-bash">git branch -b hexo   切换到`hexo`分支git add .git commit -m &quot;xxx&quot;git push origin hexo  提交就行了</code></pre><h2 id="代码高亮">代码高亮</h2><p>Hexo 本身就自带高亮功能，只不过不完美。话虽如此，这个自带的高亮功能在我所用的<a href="https://github.com/chpwang/hexo-theme-pln">主题</a>里也比市场上的其他插件（例如 <a href="https://github.com/ele828/hexo-prism-plugin">Hexo-Prism-Plugin</a> ，<a href="https://github.com/Jamling/hexo-filter-highlight">hexo-filter-highlight</a> 和 <a href="https://github.com/google/code-prettify">Prettify</a> 这三个坑货）要好用得多。这里说的好用，主要体现在最终渲染出来的排版效果上的美观、设置上的便捷，且不会引入过多 Markdown 和 Latex 之间语法的冲突。</p><p>经过一番调研，最终我放弃安装 Plugin（插件）版本的 Highlight.js（ <a href="https://github.com/Jamling/hexo-filter-highlight">hexo-filter-highlight</a> 就是一个基于 Highlight.js 开发的 Plugin 。这些 Plugin 虽然安装设置方便，其模块化属性也方便管理，但如果效果不好，不如不用），直接选择使用原版的 <a href="https://highlightjs.org/">Highlight.js</a> 。你可以在<a href="https://highlightjs.org/static/demo/">官方 Demo </a>页面查看它各个语言在各个风格（Style）下的显示效果。</p><hr><h3 id="实现">实现</h3><h5 id="步骤一">步骤一</h5><p>前往 Highlight.js 的<a href="https://highlightjs.org/download/">官方下载页面</a>，在 <strong>Custom package</strong> 的部分勾选你希望获得高亮支持的语言（想一步到位就全选），勾选完毕后点击 Download 按钮下载，得到 <code>highlight.zip</code> 压缩包；</p><h5 id="步骤二">步骤二</h5><p>解压刚刚的 <code>highlight.zip</code> 压缩包，得到 <code>highlight.pack.js</code> 文件和 <code>styles</code>文件夹（该文件夹中包含了各种<a href="https://highlightjs.org/static/demo/">显示风格</a>的 CSS 文件）。接着，将 <code>highlight.pack.js</code> 文件移动到 <code>themes/hexo-theme-Claudia/source/js/</code> 目录下，而 <code>styles</code> 文件夹（包括里面的所有 CSS 文件）则移动到 <code>themes/hexo-theme-Claudia/source/style/themes</code> 目录下；</p><h5 id="步骤三">步骤三</h5><p>修改根目录下 <code>_config.yml</code> 文件中 highlight 部分的设置（主要目的是关闭它，其他设置只是顺便说明一下）：</p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code>highlight:  enable: false 关闭 hexo 自带的 highlight*  line_number: false  auto_detect: false  tab_replace: &quot;&quot;  wrap: falsehljs:  enable: true #true to enable the plugin  line_number: frontend # 在前面加行号 in frontend or backend (不推荐，有bug）  trim_indent: backend # trim the indent of code block to prettify output. backend or front-end (recommend)  copy_code: true # show copy code in caption.  label:    left: Code    right: &quot;:&quot;    copy: copy 这里赋制按钮没用</code></pre><p>把 vs2015.css 粘贴到改 <code>themes/hexo-theme-Claudia/source/style/themes/highlight-theme-light.css</code> ，修改</p><p><code>themes/hexo-theme-Claudia/layout/post.pug</code>（通过调用指定的 CSS 文件选择相应的高亮风格，下面的例子里选择的风格是 <a href="https://highlightjs.org/static/demo/">Vs 2015</a>）：</p><p class="code-caption" data-lang="pug" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-pug">link(rel='stylesheet', href= url_for('/style/themes/vs2015.min.css'))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;git：git 可以在我们的电脑上创建一个本地仓库，然后把我们的网页部署到 github 上的 github Pages 上。&lt;/p&gt;
&lt;p&gt;node.js:安装 Hexo 的前提。&lt;/p&gt;
&lt;p&gt;Hexo：可以把我们本地的 Mark</summary>
      
    
    
    
    <category term="notes" scheme="http://example.com/categories/notes/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
    <category term="github" scheme="http://example.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/11/01/electron-vue/"/>
    <id>http://example.com/2021/11/01/electron-vue/</id>
    <published>2021-11-01T08:10:47.915Z</published>
    <updated>2021-12-15T08:46:21.742Z</updated>
    
    <content type="html"><![CDATA[<h1>迁移指南</h1><ol><li>使用 <code>vue init simulatedgreg/electron-vue my-project</code> 生成一个崭新的 electron-vue 项目</li><li>将当前项目 <code>src</code> 内的文件复制到新项目的 <code>src</code> 目录中</li><li>将 <code>package.json</code> 里的依赖关系从当前项目复制到新项目的 <code>package.json</code> 里</li><li>使用 <code>yarn</code> 或 <code>npm install</code> 安装依赖</li><li>在开发模式下运行项目 (<code>yarn run dev</code> 或 <code>npm run dev</code>)</li><li>监视控制台以修复可能出现的错误</li></ol><h3 id="问题一">问题一</h3><p>![image-20211215161813067](/Users/bytedance/Library/Application Support/typora-user-images/image-20211215161813067.png)</p><p>.electron-vue/webpack.main.config.js添加</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">externals: [  ...Object.keys(dependencies || &#123;&#125;),  &#123;'electron-debug': 'electron-debug'&#125;],</code></pre><h3 id="问题二-electron中Unable-to-install-vue-devtools的解决方法">问题二 electron中Unable to install vue-devtools的解决方法</h3><p>由于网络的问题，electron运行的时候加载vue-devtools失败。 Unable to install vue-devtools 。从日志里看retry了四次都timeout了。这个也没有淘宝镜像等国内镜像。不过后来按网上找了个方法，成功加载了最新的版本。</p><p>先 npm install vue-devtools --save-dev</p><p>然后 把ready事件里面注释掉5行，再加上一行手动加载的。最终src/main/index.dev.js里面修改后的内容如下（所有内容）：</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">/* eslint-disable */// Install `electron-debug` with `devtron`require('electron-debug')(&#123; showDevTools: true &#125;)import &#123;  BrowserWindow &#125; from 'electron';// Install `vue-devtools`require('electron').app.on('ready', () =&gt; &#123;  let installExtension = require('electron-devtools-installer')  // installExtension.default(installExtension.VUEJS_DEVTOOLS)  //   .then(() =&gt; &#123;&#125;)  //  .catch(err =&gt; &#123;  //     console.log('Unable to install `vue-devtools`: \n', err)  //   &#125;)  //参考 https://www.cnblogs.com/wozho/p/10782654.html 和 https://github.com/SimulatedGREG/electron-vue/issues/242  BrowserWindow.addDevToolsExtension('node_modules/vue-devtools/vender')  //手动加载vue-devtools，前提是 npm install vue-devtools --save-dev&#125;)// Require `main` process to boot apprequire('./index')</code></pre><p>问题三，配置vue prettier和eslint冲突</p><p>.eslintrc.js添加</p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code class="language-js">//强制使用单引号quotes: ['error', 'single'],//强制不使用分号结尾semi: ['error', 'never'],//末尾不添加逗号，这里没生效可以直接去prettier插件里配置无trailingComma: 'none',</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;迁移指南&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;vue init simulatedgreg/electron-vue my-project&lt;/code&gt; 生成一个崭新的 electron-vue 项目&lt;/li&gt;
&lt;li&gt;将当前项目 &lt;code&gt;src&lt;/code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Typography and tags</title>
    <link href="http://example.com/2017/12/20/Typography%20and%20tags/"/>
    <id>http://example.com/2017/12/20/Typography%20and%20tags/</id>
    <published>2017-12-20T05:51:07.000Z</published>
    <updated>2021-11-02T02:33:24.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="images/lake.png" alt="$cover"></p><h1>Installation</h1><hr><p>This post uses <code>hexo-renderer-markdown-it</code> plugin as markdown processor, so please install it to achieve the effect.</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-title="installation"><span class="code-caption-label">(`installation`)</span><a class="code-caption-copy"></a></p><pre><code class="language-bash">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save</code></pre><h1>Configuration</h1><p>Add following to <code>_config.yml</code> of your site.</p><p class="code-caption" data-lang="yml" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-title="_config.yml"><span class="code-caption-label">(`_config.yml`)</span><a class="code-caption-copy"></a></p><pre><code class="language-yml">markdown:  render:    html: true    xhtmlOut: false    breaks: false    linkify: true    typographer: true    quotes: '“”‘’'  plugins:    - markdown-it-abbr    - markdown-it-footnote    - markdown-it-ins    - markdown-it-sub    - markdown-it-sup    - markdown-it-deflist  anchors:    level: 2    collisionSuffix: 'v'    permalink: false    permalinkClass: header-anchor    permalinkSymbol: &quot; &quot;    permalinkBefore: false</code></pre><h1>Usage</h1><hr><h2 id="Headings">Headings</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown"># h1 Heading 8-)## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading</code></pre><h1>h1 Heading 8-)</h1><h2 id="h2-Heading">h2 Heading</h2><h3 id="h3-Heading">h3 Heading</h3><h4 id="h4-Heading">h4 Heading</h4><h5 id="h5-Heading">h5 Heading</h5><h6 id="h6-Heading">h6 Heading</h6><h2 id="Horizontal-Rules">Horizontal Rules</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">___---***</code></pre><hr><hr><hr><h2 id="Typographic-replacements">Typographic replacements</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test... test..... test?..... test!....!!!!!! ???? ,,  -- ---&quot;Smartypants, double quotes&quot; and 'single quotes'</code></pre><p>© © ® ® ™ ™ § § ±</p><p>test… test… test… test?.. test!..</p><p>!!! ??? ,  – —</p><p>“Smartypants, double quotes” and ‘single quotes’</p><h2 id="Emphasis">Emphasis</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">**This is bold text**__This is bold text__*This is italic text*_This is italic text_~~Strikethrough~~</code></pre><p><strong>This is bold text</strong></p><p><strong>This is bold text</strong></p><p><em>This is italic text</em></p><p><em>This is italic text</em></p><p><s>Strikethrough</s></p><h2 id="Blockquotes">Blockquotes</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">&gt; Blockquotes can also be nested...&gt;&gt; ...by using additional greater-than signs right next to each other...&gt; &gt; &gt; ...or with spaces between arrows.</code></pre><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="Lists">Lists</h2><h3 id="Unordered">Unordered</h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">+ Create a list by starting a line with `+`, `-`, or `*`+ Sub-lists are made by indenting 2 spaces:  - Marker character change forces new list start:    * Ac tristique libero volutpat at    + Facilisis in pretium nisl aliquet    - Nulla volutpat aliquam velit+ Very easy!</code></pre><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li>Sub-lists are made by indenting 2 spaces:<ul><li>Marker character change forces new list start:<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><h3 id="Ordered">Ordered</h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">1. Lorem ipsum dolor sit amet  1. Indented list    1. Another level  2. Indent2. Consectetur adipiscing elit3. Integer molestie lorem at massa</code></pre><ol><li>Lorem ipsum dolor sit amet</li><li>Indented list<ol><li>Another level</li></ol></li><li>Indent</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">1. You can use sequential numbers...1. ...or keep all the numbers as `1.`</code></pre><ol><li>You can use sequential numbers…</li><li>…or keep all the numbers as <code>1.</code></li></ol><h4 id="Start-numbering-with-offset">Start numbering with offset:</h4><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">57. foo1. bar</code></pre><ol start="57"><li>foo</li><li>bar</li></ol><h2 id="Code">Code</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Inline `code`</code></pre><p>Inline <code>code</code></p><h3 id="Indented-code">Indented code</h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">// Some comments    line 1 of code    line 2 of code    line 3 of code</code></pre><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><h3 id="Block-code-“fences”">Block code “fences”</h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">```Sample text here...```</code></pre><pre><code>Sample text here...&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;</code></pre><p>Syntax highlighting</p><pre><code class="language-markdown">``` js sample.jsvar foo = function (bar) &#123;  return bar++;&#125;;console.log(foo(5));```</code></pre><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-title="sample.js"><span class="code-caption-label">(`sample.js`)</span><a class="code-caption-copy"></a></p><pre><code class="language-js">var foo = function (bar) &#123;  return bar++;&#125;;console.log(foo(5));</code></pre><h2 id="Tables">Tables</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">| Option | Description |Description | Description | Description | Description || ------ | ----------- |----------- | ----------- | ----------- | ----------- || data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th>Option</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td><td></td><td></td><td></td><td></td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td><td></td><td></td><td></td><td></td></tr><tr><td>ext</td><td>extension to be used for dest files.</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="Right-aligned-columns">Right aligned columns</h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">| Option | Description || ------:| -----------:|| data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th style="text-align:right">Option</th><th style="text-align:right">Description</th></tr></thead><tbody><tr><td style="text-align:right">data</td><td style="text-align:right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td style="text-align:right">engine</td><td style="text-align:right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td style="text-align:right">ext</td><td style="text-align:right">extension to be used for dest files.</td></tr></tbody></table><h2 id="Links">Links</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">[link text](http://dev.nodeca.com)</code></pre><p><a href="http://dev.nodeca.com">link text</a></p><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">[link with title](http://nodeca.github.io/pica/demo/ &quot;title text!&quot;)</code></pre><p><a href="http://nodeca.github.io/pica/demo/" title="title text!">link with title</a></p><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Autoconverted link https://github.com/nodeca/pica (enabled linkify)</code></pre><p>Autoconverted link <a href="https://github.com/nodeca/pica">https://github.com/nodeca/pica</a> (enabled linkify)</p><h2 id="Images">Images</h2><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">![Minion](https://octodex.github.com/images/minion.png)![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg &quot;The Stormtroopocat&quot;)</code></pre><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p><p>Like links, Images also have a footnote style syntax</p><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">![Alt text][id]With a reference later in the document defining the URL location:[id]: https://octodex.github.com/images/dojocat.jpg  &quot;The Dojocat&quot;</code></pre><p><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p><p>With a reference later in the document defining the URL location:</p><h2 id="Plugins">Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin">syntax plugins</a>. The sample <a href="#configuration">configuration snippet</a></p><h3 id="Emojies"><a href="https://github.com/markdown-it/markdown-it-emoji">Emojies</a></h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:Shortcuts (emoticons): :-) :-( 8-) ;)</code></pre><p>Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:</p><p>Shortcuts (emoticons): :-) :-( 8-) ;)</p><h3 id="Subscript-Superscript"><a href="https://github.com/markdown-it/markdown-it-sub">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup">Superscript</a></h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Superscript: 19^th^Subscript: H~2~O</code></pre><p>Superscript: 19^th^</p><p>Subscript: H~2~O</p><h3 id="ins"><a href="https://github.com/markdown-it/markdown-it-ins">&lt;ins&gt;</a></h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">++Inserted text++</code></pre><p>++Inserted text++</p><h3 id="mark"><a href="https://github.com/markdown-it/markdown-it-mark">&lt;mark&gt;</a></h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">==Marked text==</code></pre><p>==Marked text==</p><h3 id="Footnotes"><a href="https://github.com/markdown-it/markdown-it-footnote">Footnotes</a></h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup**    and multiple paragraphs.[^second]: Footnote text.</code></pre><p>Footnote 1 link[^first].</p><p>Footnote 2 link[^second].</p><p>Inline footnote^[Text of inline footnote] definition.</p><p>Duplicated footnote reference[^second].</p><p>[^first]: Footnote <strong>can have markup</strong></p><pre><code>and multiple paragraphs.</code></pre><p>[^second]: Footnote text.</p><h3 id="Definition-lists"><a href="https://github.com/markdown-it/markdown-it-deflist">Definition lists</a></h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Term 1:   Definition 1with lazy continuation.</code></pre><p>Term 1<br>:   Definition 1<br>with lazy continuation.</p><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Term 2 with *inline markup*:   Definition 2        &#123; some code, part of Definition 2 &#125;    Third paragraph of definition 2.</code></pre><p>Term 2 with <em>inline markup</em><br>:   Definition 2</p><pre><code>    &#123; some code, part of Definition 2 &#125;Third paragraph of definition 2.</code></pre><p><em>Compact style:</em></p><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">Term 1  ~ Definition 1Term 2  ~ Definition 2a  ~ Definition 2b</code></pre><p>Term 1<br>~ Definition 1</p><p>Term 2<br>~ Definition 2a<br>~ Definition 2b</p><h3 id="Abbreviations"><a href="https://github.com/markdown-it/markdown-it-abbr">Abbreviations</a></h3><p class="code-caption" data-lang="markdown" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-markdown">This is HTML abbreviation example.It converts &quot;HTML&quot;, but keep intact partial entries like &quot;xxxHTMLyyy&quot; and so on.*[HTML]: Hyper Text Markup Language</code></pre><p>This is HTML abbreviation example.</p><p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p><p>*[HTML]: Hyper Text Markup Language</p><h3 id="Custom-containers"><a href="https://github.com/markdown-it/markdown-it-container">Custom containers</a></h3><p>::: warning<br><em>here be dragons</em><br>:::</p><h2 id="Hexo-Built-in-Tags">Hexo Built-in Tags</h2><h3 id="Blockquote-with-author">Blockquote with author</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125;</code></pre><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Blockquote-for-twitter">Blockquote for twitter</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http://devdocs.io&#123;% endblockquote %&#125;</code></pre><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Blockquote-for-weblink">Blockquote for weblink</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125;</code></pre><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h3 id="Pull-Quotes">Pull Quotes</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% pullquote %&#125;content&#123;% endpullquote %&#125;</code></pre><blockquote class="pullquote"><p>content</p></blockquote><h3 id="jsFiddle">jsFiddle</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% jsfiddle o2gxgz9r default light %&#125;</code></pre><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/o2gxgz9r/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen></iframe><h3 id="Gist">Gist</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% gist b6365e79be6052e7531e7ba6ea8caf23 'Sample gist' %&#125;</code></pre><script src="//gist.github.com/b6365e79be6052e7531e7ba6ea8caf23.js?file=Sample gist"></script><h3 id="iFrame">iFrame</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% iframe https://www.bing.com %&#125;</code></pre><iframe src="https://www.bing.com/" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><h3 id="Link-to-open-in-new-tab">Link to open in new tab</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% link Google https://www.google.com default Google %&#125;</code></pre><a href="https://www.google.com/" title="default Google" target="">Google</a><h3 id="Youtube">Youtube</h3><p class="code-caption" data-lang="swig" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="" data-hide="false" data-href="code"><span class="code-caption-label">([source](code))</span><a class="code-caption-copy"></a></p><pre><code class="language-swig">&#123;% youtube l_lblj8Cq0o %&#125;</code></pre><div class="video-container"><iframe src="https://www.youtube.com/embed/l_lblj8Cq0o" frameborder="0" loading="lazy" allowfullscreen></iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;images/lake.png&quot; alt=&quot;$cover&quot;&gt;&lt;/p&gt;
&lt;h1&gt;Installation&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;This post uses &lt;code&gt;hexo-renderer-markdown-it&lt;/code&gt; plugin a</summary>
      
    
    
    
    <category term="notes" scheme="http://example.com/categories/notes/"/>
    
    
    <category term="typography" scheme="http://example.com/tags/typography/"/>
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Images video</title>
    <link href="http://example.com/2013/12/26/images/"/>
    <id>http://example.com/2013/12/26/images/</id>
    <published>2013-12-26T14:46:49.000Z</published>
    <updated>2021-11-02T02:40:45.598Z</updated>
    
    <content type="html"><![CDATA[<p>title:  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam justo turpis, tincidunt ac convallis id.<br>date: 2013-12-24 23:31:06  长title</p><p>无title</p><h2 id="tags">tags:</h2><p><img src="https://source.unsplash.com/random/400x400?building" alt="cover"><br>This post doesn’t have a title. Make sure it’s accessible.</p><h2 id="tags-2">tags:</h2><p>This post has a long title. Make sure the title displayed right.</p><p>This is a image test post1</p><p><img src="/images/river.png" alt=""><br><img src="images/landscape-1.jpg" alt=""><br><img src="images/landscape-2.jpg" alt=""><br><img src="images/leaf.jpg" alt="Caption"></p><p>This is a video test post.</p><p><strong>Youtube</strong></p><div class="video-container"><iframe src="https://www.youtube.com/embed/TIbZDRXM-Tg" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p><strong>Vimeo</strong></p><div class="video-container"><iframe src="https://player.vimeo.com/video/82090131" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>photos:</p><ul><li>/assets/wallpaper-2572384.jpg</li><li>/assets/wallpaper-2311325.jpg</li><li>/assets/wallpaper-878514.jpg</li><li><a href="http://placehold.it/350x150.jpg">http://placehold.it/350x150.jpg</a></li></ul><h2 id="link-http-www-google-com">link: <a href="http://www.google.com/">http://www.google.com/</a></h2><p>This is a link post. Clicking on the link should open <a href="http://www.google.com/">Google</a> in a new tab or window.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title:  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam justo turpis, tincidunt ac convallis id.&lt;br&gt;
date: 2013-12-24 23</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Tag Plugins</title>
    <link href="http://example.com/2013/12/25/tag-plugins/"/>
    <id>http://example.com/2013/12/25/tag-plugins/</id>
    <published>2013-12-24T16:14:39.000Z</published>
    <updated>2021-09-21T01:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>This post is used for testing tag plugins. See <a href="http://zespia.tw/hexo/docs/tag-plugins.html">docs</a> for more info.</p><h2 id="Block-Quote">Block Quote</h2><h3 id="Normal-blockquote">Normal blockquote</h3><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><h3 id="Quote-from-a-book">Quote from a book</h3><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Quote-from-Twitter">Quote from Twitter</h3><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Quote-from-an-article-on-the-web">Quote from an article on the web</h3><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Code-Block">Code Block</h2><h3 id="Normal-code-block">Normal code block</h3><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy=""><span class="code-caption-label"></span><a class="code-caption-copy"></a></p><pre><code>alert('Hello World!');</code></pre><h3 id="With-caption">With caption</h3><pre><code>array.map(callback[, thisArg])</code></pre><h3 id="With-caption-and-URL">With caption and URL</h3><pre><code>.compact([0, 1, false, 2, ‘’, 3]);&#x3D;&gt; [1, 2, 3]</code></pre><h3 id="With-marked-lines">With marked lines</h3><p>Line 1,7-8,10 should be marked with different color.</p><pre><code>const http &#x3D; require(&#39;http&#39;);const hostname &#x3D; &#39;127.0.0.1&#39;;const port &#x3D; 1337;http.createServer((req, res) &#x3D;&gt; {  res.writeHead(200, { &#39;Content-Type&#39;: &#39;text&#x2F;plain&#39; });  res.end(&#39;Hello World\n&#39;);}).listen(port, hostname, () &#x3D;&gt; {  console.log(&#96;Server running at http:&#x2F;&#x2F;${hostname}:${port}&#x2F;&#96;);});</code></pre><p>Note: Theme’s style should support <code>.highlight.line.marked</code> (recommend to use the selection or current line color).</p><h3 id="Gist">Gist</h3><script src="//gist.github.com/996818.js"></script><h3 id="jsFiddle">jsFiddle</h3><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/ccWP7/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen></iframe><h2 id="Pullquote">Pullquote</h2><h3 id="Left">Left</h3><blockquote class="pullquote left"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.</p><h3 id="Right">Right</h3><blockquote class="pullquote right"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;This post is used for testing tag plugins. See &lt;a href=&quot;http://zespia.tw/hexo/docs/tag-plugins.html&quot;&gt;docs&lt;/a&gt; for more info.&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Elements</title>
    <link href="http://example.com/2013/12/24/elements/"/>
    <id>http://example.com/2013/12/24/elements/</id>
    <published>2013-12-24T15:29:08.000Z</published>
    <updated>2021-11-04T08:32:42.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://source.unsplash.com/random/800x400?lake" alt="cover"><br>The purpose of this post is to help you make sure all of HTML elements can display properly. If you use CSS reset, don’t forget to redefine the style by yourself.</p><hr><h1>![image-20211104162822342](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104162822342.png)</h1><h1>![image-20211104162922598](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104162922598.png)Heading 1</h1><h2 id="image-20211104163129557-Users-bytedance-Library-Application-Support-typora-user-images-image-20211104163129557-png-Heading-2">![image-20211104163129557](/Users/bytedance/Library/Application Support/typora-user-images/image-20211104163129557.png)Heading 2</h2><h3 id="Heading-3">Heading 3</h3><h4 id="Heading-4">Heading 4</h4><h5 id="Heading-5">Heading 5</h5><h6 id="Heading-6">Heading 6</h6><hr><h2 id="Paragraph">Paragraph</h2><p>Lorem ipsum dolor sit amet, <a href="">test link</a> consectetur adipiscing elit. <strong>Strong text</strong> pellentesque ligula commodo viverra vehicula. <em>Italic text</em> at ullamcorper enim. Morbi a euismod nibh. <u>Underline text</u> non elit nisl. <s>Deleted text</s> tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan.</p><p>Interdum et malesuada fames ac ante ipsum primis in faucibus. <code>Sed erat diam</code>, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget.</p><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><p>Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat. Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet.</p><h2 id="List-Types">List Types</h2><h3 id="Definition-List-dl">Definition List (dl)</h3><dl><dt>Definition List Title</dt><dd>This is a definition list division.</dd></dl><h3 id="Ordered-List-ol">Ordered List (ol)</h3><ol><li>List Item 1</li><li>List Item 2</li><li>List Item 3</li></ol><h3 id="Unordered-List-ul">Unordered List (ul)</h3><ul><li>List Item 1</li><li>List Item 2</li><li>List Item 3</li></ul><h3 id="Checkbox-List-ul">Checkbox List (ul)</h3><ul><li>[ ] List Item 1 unchecked</li><li>[x] List Item 2 checked</li><li>[X] List Item 3 checked</li></ul><h2 id="Table">Table</h2><table><thead><tr><th>Table Header 1</th><th>Table Header 2</th><th>Table Header 3</th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr></tbody></table><h2 id="Misc-Stuff-abbr-acronym-sub-sup-etc">Misc Stuff - abbr, acronym, sub, sup, etc.</h2><p>Lorem <sup>superscript</sup> dolor <sub>subscript</sub> amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. <cite>cite</cite>. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. <acronym title="National Basketball Association">NBA</acronym> Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.  <abbr title="Avenue">AVE</abbr></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://source.unsplash.com/random/800x400?lake&quot; alt=&quot;cover&quot;&gt;&lt;br&gt;
The purpose of this post is to help you make sure all of HTML</summary>
      
    
    
    
    
  </entry>
  
</feed>
